---
phase: 34-symbol-extraction-expansion
plan: 02
type: execute
wave: 2
depends_on: ["34-01"]
files_modified:
  - src/cocosearch/indexer/symbols.py
  - src/cocosearch/indexer/queries/java.scm
  - src/cocosearch/indexer/queries/ruby.scm
  - tests/unit/indexer/test_symbols.py
autonomous: true

must_haves:
  truths:
    - "Java files have classes, interfaces, enums, methods extracted as symbols"
    - "Ruby files have classes, modules, methods extracted as symbols"
    - "Java method names include parent class (MyClass.myMethod)"
    - "Ruby method names include parent class/module (MyClass.my_method)"
  artifacts:
    - path: "src/cocosearch/indexer/queries/java.scm"
      provides: "Java symbol extraction query"
      min_lines: 15
    - path: "src/cocosearch/indexer/queries/ruby.scm"
      provides: "Ruby symbol extraction query"
      min_lines: 10
    - path: "tests/unit/indexer/test_symbols.py"
      provides: "Tests for Java and Ruby extraction"
      contains: "test_java"
  key_links:
    - from: "src/cocosearch/indexer/symbols.py"
      to: "LANGUAGE_MAP"
      via: "file extension mapping"
      pattern: '"java".*:.*"java"'
---

<objective>
Add Java and Ruby symbol extraction support using external query files.

Purpose: Extend symbol coverage to 7 languages. Java and Ruby are high-value targets for enterprise and web development codebases.

Output: Query files for Java and Ruby, updated LANGUAGE_MAP, comprehensive tests.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/34-symbol-extraction-expansion/34-CONTEXT.md
@.planning/phases/34-symbol-extraction-expansion/34-RESEARCH.md
@.planning/phases/34-symbol-extraction-expansion/34-01-SUMMARY.md
@src/cocosearch/indexer/symbols.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Java symbol extraction</name>
  <files>
    src/cocosearch/indexer/queries/java.scm
    src/cocosearch/indexer/symbols.py
  </files>
  <action>
1. Create src/cocosearch/indexer/queries/java.scm:
```scheme
;; @doc Java symbol extraction: classes, interfaces, enums, methods, constructors

;; Class declarations
(class_declaration
  name: (identifier) @name) @definition.class

;; Interface declarations
(interface_declaration
  name: (identifier) @name) @definition.interface

;; Enum declarations
(enum_declaration
  name: (identifier) @name) @definition.enum

;; Method declarations
(method_declaration
  name: (identifier) @name) @definition.method

;; Constructor declarations
(constructor_declaration
  name: (identifier) @name) @definition.method
```

2. Update LANGUAGE_MAP in symbols.py to include Java:
```python
LANGUAGE_MAP = {
    # ... existing mappings ...
    # Java
    "java": "java",
}
```

3. Update container_types in _build_qualified_name() for Java:
```python
container_types = {
    # ... existing ...
    "java": ["class_declaration", "interface_declaration", "enum_declaration"],
}
```

4. Update _build_signature() to handle Java method signatures:
   - Include return type: `public void myMethod(String arg)`
   - Include modifiers: public/private/protected
   - Format: `{modifiers} {return_type} {name}{parameters}`

5. Test with sample Java code:
```java
public class UserService {
    private String name;

    public UserService(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

interface Repository {
    void save(Object entity);
}

enum Status {
    ACTIVE, INACTIVE
}
```
  </action>
  <verify>
    - `python -c "from cocosearch.indexer.symbols import extract_symbol_metadata; print(extract_symbol_metadata('public class Foo {}', 'java'))"` returns class symbol
    - Java methods in classes have qualified names (ClassName.methodName)
  </verify>
  <done>
    Java symbol extraction working with classes, interfaces, enums, methods, constructors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Ruby symbol extraction</name>
  <files>
    src/cocosearch/indexer/queries/ruby.scm
    src/cocosearch/indexer/symbols.py
  </files>
  <action>
1. Create src/cocosearch/indexer/queries/ruby.scm:
```scheme
;; @doc Ruby symbol extraction: classes, modules, methods

;; Instance methods
(method
  name: (_) @name) @definition.method

;; Singleton methods (class methods: def self.foo)
(singleton_method
  name: (_) @name) @definition.method

;; Classes
(class
  name: [(constant) (scope_resolution)] @name) @definition.class

;; Modules
(module
  name: [(constant) (scope_resolution)] @name) @definition.module
```

2. Update LANGUAGE_MAP in symbols.py to include Ruby:
```python
LANGUAGE_MAP = {
    # ... existing mappings ...
    # Ruby
    "rb": "ruby",
    "ruby": "ruby",
}
```

3. Update container_types in _build_qualified_name() for Ruby:
```python
container_types = {
    # ... existing ...
    "ruby": ["class", "module"],
}
```

4. Update _build_signature() to handle Ruby method signatures:
   - Instance methods: `def method_name(args)`
   - Singleton methods: `def self.method_name(args)`

5. Update _map_symbol_type() to handle Ruby module:
```python
mapping = {
    # ... existing ...
    "module": "class",  # Map Ruby module to class
}
```

6. Test with sample Ruby code:
```ruby
module Authentication
  class User
    attr_reader :name

    def initialize(name)
      @name = name
    end

    def self.find(id)
      # class method
    end

    def greet
      "Hello, #{@name}"
    end
  end
end
```
  </action>
  <verify>
    - `python -c "from cocosearch.indexer.symbols import extract_symbol_metadata; print(extract_symbol_metadata('class Foo; end', 'rb'))"` returns class symbol
    - Ruby methods in classes have qualified names (ClassName.method_name)
  </verify>
  <done>
    Ruby symbol extraction working with classes, modules, instance methods, singleton methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for Java and Ruby extraction</name>
  <files>
    tests/unit/indexer/test_symbols.py
  </files>
  <action>
1. Add Java test cases to tests/unit/indexer/test_symbols.py:

```python
# ============================================================================
# Java Tests
# ============================================================================

class TestJavaSymbolExtraction:
    """Test Java symbol extraction."""

    def test_java_class(self):
        code = "public class UserService {}"
        result = extract_symbol_metadata(code, "java")
        assert result["symbol_type"] == "class"
        assert result["symbol_name"] == "UserService"
        assert "class" in result["symbol_signature"]

    def test_java_interface(self):
        code = "public interface Repository {}"
        result = extract_symbol_metadata(code, "java")
        assert result["symbol_type"] == "interface"
        assert result["symbol_name"] == "Repository"

    def test_java_enum(self):
        code = "public enum Status { ACTIVE, INACTIVE }"
        result = extract_symbol_metadata(code, "java")
        assert result["symbol_type"] == "class"  # enum maps to class
        assert result["symbol_name"] == "Status"

    def test_java_method(self):
        code = '''
public class Foo {
    public String getName() {
        return name;
    }
}
'''
        result = extract_symbol_metadata(code, "java")
        # First symbol is the class
        assert result["symbol_type"] == "class"

    def test_java_method_qualified_name(self):
        """Methods should have qualified names when extracted individually."""
        code = '''
public class Foo {
    public void bar() {}
}
'''
        from cocosearch.indexer.symbols import _extract_symbols_with_query, resolve_query_file
        query = resolve_query_file("java")
        symbols = _extract_symbols_with_query(code, "java", query)
        method_symbols = [s for s in symbols if s["symbol_type"] == "method"]
        assert any("Foo.bar" in s["symbol_name"] for s in method_symbols)

    def test_java_constructor(self):
        code = '''
public class User {
    public User(String name) {}
}
'''
        from cocosearch.indexer.symbols import _extract_symbols_with_query, resolve_query_file
        query = resolve_query_file("java")
        symbols = _extract_symbols_with_query(code, "java", query)
        method_symbols = [s for s in symbols if s["symbol_type"] == "method"]
        assert any("User" in s["symbol_name"] for s in method_symbols)
```

2. Add Ruby test cases:

```python
# ============================================================================
# Ruby Tests
# ============================================================================

class TestRubySymbolExtraction:
    """Test Ruby symbol extraction."""

    def test_ruby_class(self):
        code = "class UserService; end"
        result = extract_symbol_metadata(code, "rb")
        assert result["symbol_type"] == "class"
        assert result["symbol_name"] == "UserService"

    def test_ruby_module(self):
        code = "module Authentication; end"
        result = extract_symbol_metadata(code, "rb")
        assert result["symbol_type"] == "class"  # module maps to class
        assert result["symbol_name"] == "Authentication"

    def test_ruby_instance_method(self):
        code = '''
class Foo
  def bar
    "hello"
  end
end
'''
        result = extract_symbol_metadata(code, "rb")
        # First symbol is the class
        assert result["symbol_type"] == "class"

    def test_ruby_method_qualified_name(self):
        """Methods should have qualified names."""
        code = '''
class Foo
  def bar
  end
end
'''
        from cocosearch.indexer.symbols import _extract_symbols_with_query, resolve_query_file
        query = resolve_query_file("ruby")
        symbols = _extract_symbols_with_query(code, "ruby", query)
        method_symbols = [s for s in symbols if s["symbol_type"] == "method"]
        assert any("Foo.bar" in s["symbol_name"] for s in method_symbols)

    def test_ruby_singleton_method(self):
        code = '''
class Foo
  def self.class_method
  end
end
'''
        from cocosearch.indexer.symbols import _extract_symbols_with_query, resolve_query_file
        query = resolve_query_file("ruby")
        symbols = _extract_symbols_with_query(code, "ruby", query)
        method_symbols = [s for s in symbols if s["symbol_type"] == "method"]
        assert len(method_symbols) > 0

    def test_ruby_nested_module_class(self):
        code = '''
module Auth
  class User
  end
end
'''
        from cocosearch.indexer.symbols import _extract_symbols_with_query, resolve_query_file
        query = resolve_query_file("ruby")
        symbols = _extract_symbols_with_query(code, "ruby", query)
        class_symbols = [s for s in symbols if s["symbol_type"] == "class"]
        assert len(class_symbols) >= 2  # module and class
```

3. Run all tests: `pytest tests/unit/indexer/test_symbols.py -v`
  </action>
  <verify>
    - `pytest tests/unit/indexer/test_symbols.py::TestJavaSymbolExtraction -v` all pass
    - `pytest tests/unit/indexer/test_symbols.py::TestRubySymbolExtraction -v` all pass
    - `pytest tests/unit/indexer/test_symbols.py -v` full suite passes
  </verify>
  <done>
    Comprehensive tests for Java and Ruby symbol extraction passing
  </done>
</task>

</tasks>

<verification>
1. Java: `python -c "from cocosearch.indexer.symbols import extract_symbol_metadata; print(extract_symbol_metadata('public class Foo {}', 'java'))"`
2. Ruby: `python -c "from cocosearch.indexer.symbols import extract_symbol_metadata; print(extract_symbol_metadata('class Foo; end', 'rb'))"`
3. Tests: `pytest tests/unit/indexer/test_symbols.py -v -k "java or ruby"`
</verification>

<success_criteria>
- Java files indexed with classes, interfaces, enums, methods as symbols
- Ruby files indexed with classes, modules, methods as symbols
- Method names include parent class context
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/34-symbol-extraction-expansion/34-02-SUMMARY.md`
</output>
