---
phase: 34-symbol-extraction-expansion
plan: 04
type: execute
wave: 2
depends_on: ["34-01"]
files_modified:
  - src/cocosearch/indexer/symbols.py
  - src/cocosearch/indexer/queries/php.scm
  - tests/unit/indexer/test_symbols.py
autonomous: true

must_haves:
  truths:
    - "PHP files have functions, classes, interfaces, traits extracted as symbols"
    - "PHP method names include parent class (MyClass::myMethod or MyClass.myMethod)"
    - "PHP traits are extracted with interface symbol type"
    - "10 total languages supported after this plan"
  artifacts:
    - path: "src/cocosearch/indexer/queries/php.scm"
      provides: "PHP symbol extraction query"
      min_lines: 15
    - path: "tests/unit/indexer/test_symbols.py"
      provides: "Tests for PHP extraction"
      contains: "test_php"
  key_links:
    - from: "src/cocosearch/indexer/symbols.py"
      to: "LANGUAGE_MAP"
      via: "file extension mapping"
      pattern: '"php".*:.*"php"'
---

<objective>
Add PHP symbol extraction support using external query files.

Purpose: Complete the 10-language coverage goal. PHP is essential for web development codebases (WordPress, Laravel, Symfony, etc.).

Output: Query file for PHP, updated LANGUAGE_MAP, comprehensive tests, verification of all 10 languages working.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/34-symbol-extraction-expansion/34-CONTEXT.md
@.planning/phases/34-symbol-extraction-expansion/34-RESEARCH.md
@.planning/phases/34-symbol-extraction-expansion/34-01-SUMMARY.md
@src/cocosearch/indexer/symbols.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PHP symbol extraction</name>
  <files>
    src/cocosearch/indexer/queries/php.scm
    src/cocosearch/indexer/symbols.py
  </files>
  <action>
1. Create src/cocosearch/indexer/queries/php.scm:
```scheme
;; @doc PHP symbol extraction: functions, classes, interfaces, traits, methods

;; Functions
(function_definition
  name: (name) @name) @definition.function

;; Classes
(class_declaration
  name: (name) @name) @definition.class

;; Interfaces
(interface_declaration
  name: (name) @name) @definition.interface

;; Traits
(trait_declaration
  name: (name) @name) @definition.trait

;; Methods
(method_declaration
  name: (name) @name) @definition.method
```

2. Update LANGUAGE_MAP in symbols.py to include PHP:
```python
LANGUAGE_MAP = {
    # ... existing mappings ...
    # PHP
    "php": "php",
}
```

3. Update container_types in _build_qualified_name() for PHP:
```python
container_types = {
    # ... existing ...
    "php": ["class_declaration", "interface_declaration", "trait_declaration"],
}
```

4. Update _map_symbol_type() for PHP trait:
```python
mapping = {
    # ... existing ...
    "trait": "interface",  # PHP trait maps to interface
}
```

5. Update _build_signature() to handle PHP signatures:
   - Include visibility: `public function myMethod()`
   - Include return types: `function foo(): string`
   - Handle static methods: `public static function bar()`

6. Test with sample PHP code:
```php
<?php

namespace App\Services;

interface Repository {
    public function find(int $id): ?object;
}

trait Loggable {
    public function log(string $message): void {
        // log implementation
    }
}

class UserService implements Repository {
    use Loggable;

    private string $name;

    public function __construct(string $name) {
        $this->name = $name;
    }

    public function find(int $id): ?object {
        return null;
    }

    public static function create(): self {
        return new self("default");
    }
}

function helper(): void {
    // standalone function
}
```
  </action>
  <verify>
    - `python -c "from cocosearch.indexer.symbols import extract_symbol_metadata; print(extract_symbol_metadata('<?php class Foo {}', 'php'))"` returns class symbol
    - PHP methods in classes have qualified names
  </verify>
  <done>
    PHP symbol extraction working with functions, classes, interfaces, traits, methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for PHP extraction</name>
  <files>
    tests/unit/indexer/test_symbols.py
  </files>
  <action>
1. Add PHP test cases to tests/unit/indexer/test_symbols.py:

```python
# ============================================================================
# PHP Tests
# ============================================================================

class TestPhpSymbolExtraction:
    """Test PHP symbol extraction."""

    def test_php_class(self):
        code = "<?php class UserService {}"
        result = extract_symbol_metadata(code, "php")
        assert result["symbol_type"] == "class"
        assert result["symbol_name"] == "UserService"

    def test_php_interface(self):
        code = "<?php interface Repository {}"
        result = extract_symbol_metadata(code, "php")
        assert result["symbol_type"] == "interface"
        assert result["symbol_name"] == "Repository"

    def test_php_trait(self):
        code = "<?php trait Loggable {}"
        result = extract_symbol_metadata(code, "php")
        assert result["symbol_type"] == "interface"  # trait maps to interface
        assert result["symbol_name"] == "Loggable"

    def test_php_function(self):
        code = "<?php function helper() {}"
        result = extract_symbol_metadata(code, "php")
        assert result["symbol_type"] == "function"
        assert result["symbol_name"] == "helper"

    def test_php_method_qualified_name(self):
        """Methods should have qualified names."""
        code = '''<?php
class Foo {
    public function bar() {}
}
'''
        from cocosearch.indexer.symbols import _extract_symbols_with_query, resolve_query_file
        query = resolve_query_file("php")
        symbols = _extract_symbols_with_query(code, "php", query)
        method_symbols = [s for s in symbols if s["symbol_type"] == "method"]
        assert any("Foo" in s["symbol_name"] and "bar" in s["symbol_name"] for s in method_symbols)

    def test_php_constructor(self):
        code = '''<?php
class User {
    public function __construct(string $name) {}
}
'''
        from cocosearch.indexer.symbols import _extract_symbols_with_query, resolve_query_file
        query = resolve_query_file("php")
        symbols = _extract_symbols_with_query(code, "php", query)
        method_symbols = [s for s in symbols if s["symbol_type"] == "method"]
        assert any("__construct" in s["symbol_name"] for s in method_symbols)

    def test_php_static_method(self):
        code = '''<?php
class Factory {
    public static function create() {}
}
'''
        from cocosearch.indexer.symbols import _extract_symbols_with_query, resolve_query_file
        query = resolve_query_file("php")
        symbols = _extract_symbols_with_query(code, "php", query)
        method_symbols = [s for s in symbols if s["symbol_type"] == "method"]
        assert len(method_symbols) >= 1
```

2. Run PHP tests: `pytest tests/unit/indexer/test_symbols.py::TestPhpSymbolExtraction -v`
  </action>
  <verify>
    - `pytest tests/unit/indexer/test_symbols.py::TestPhpSymbolExtraction -v` all pass
  </verify>
  <done>
    Comprehensive tests for PHP symbol extraction passing
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify all 10 languages and update documentation</name>
  <files>
    src/cocosearch/indexer/symbols.py
  </files>
  <action>
1. Create a comprehensive verification test that checks all 10 languages:

```python
# In tests/unit/indexer/test_symbols.py

class TestAllLanguagesSupported:
    """Verify all 10 languages are supported."""

    @pytest.mark.parametrize("ext,code,expected_type", [
        ("py", "def foo(): pass", "function"),
        ("js", "function foo() {}", "function"),
        ("ts", "interface Foo {}", "interface"),
        ("go", "func foo() {}", "function"),
        ("rs", "fn foo() {}", "function"),
        ("java", "public class Foo {}", "class"),
        ("rb", "class Foo; end", "class"),
        ("c", "int foo() { return 0; }", "function"),
        ("cpp", "class Foo {};", "class"),
        ("php", "<?php class Foo {}", "class"),
    ])
    def test_language_supported(self, ext, code, expected_type):
        """Each of the 10 languages should extract symbols."""
        result = extract_symbol_metadata(code, ext)
        assert result["symbol_type"] == expected_type, f"Failed for {ext}"
        assert result["symbol_name"] is not None, f"No symbol name for {ext}"
```

2. Update the module docstring in symbols.py to reflect all 10 languages:

```python
"""Symbol extraction using tree-sitter for multiple programming languages.

Extracts function, class, method, and interface definitions from source code
using tree-sitter query-based parsing. Provides metadata for symbol-aware
indexing and search.

Supported languages (10):
- Python: functions, classes, methods (async supported)
- JavaScript: functions, arrow functions, classes, methods
- TypeScript: functions, classes, methods, interfaces, type aliases
- Go: functions, methods (with receiver), structs, interfaces
- Rust: functions, methods (in impl blocks), structs, traits, enums
- Java: functions, classes, interfaces, enums, methods, constructors (NEW)
- Ruby: functions, classes, modules, methods, singleton methods (NEW)
- C: functions, structs, enums, typedefs (NEW)
- C++: functions, classes, structs, namespaces, methods (NEW)
- PHP: functions, classes, interfaces, traits, methods (NEW)

Features:
- External .scm query files for user extensibility
- Query file override: Project (.cocosearch/queries/) > User (~/.cocosearch/queries/) > Built-in
- Qualified names for methods: "ClassName.method_name" (or "::" for C++)
- Graceful error handling (returns NULL fields on parse errors)
"""
```

3. Run full test suite to verify nothing is broken:
   `pytest tests/unit/indexer/test_symbols.py -v`

4. Verify all query files exist:
```bash
ls -la src/cocosearch/indexer/queries/*.scm
# Should show: python.scm, javascript.scm, typescript.scm, go.scm, rust.scm,
#              java.scm, ruby.scm, c.scm, cpp.scm, php.scm
```

5. Verify LANGUAGE_MAP has all extensions:
```python
from cocosearch.indexer.symbols import LANGUAGE_MAP
expected = ['py', 'python', 'js', 'jsx', 'mjs', 'cjs', 'ts', 'tsx', 'mts', 'cts',
            'go', 'rs', 'java', 'rb', 'ruby', 'c', 'h', 'cpp', 'cxx', 'cc',
            'hpp', 'hxx', 'hh', 'php']
for ext in expected:
    assert ext in LANGUAGE_MAP, f"Missing: {ext}"
print("All extensions mapped!")
```
  </action>
  <verify>
    - `pytest tests/unit/indexer/test_symbols.py -v` - all tests pass
    - `ls src/cocosearch/indexer/queries/*.scm | wc -l` returns 10
    - All 10 languages produce symbols when tested with sample code
  </verify>
  <done>
    All 10 languages verified working, documentation updated, full test suite passes
  </done>
</task>

</tasks>

<verification>
1. PHP: `python -c "from cocosearch.indexer.symbols import extract_symbol_metadata; print(extract_symbol_metadata('<?php class Foo {}', 'php'))"`
2. All languages: `pytest tests/unit/indexer/test_symbols.py::TestAllLanguagesSupported -v`
3. Query files: `ls src/cocosearch/indexer/queries/*.scm | wc -l` should be 10
4. Full suite: `pytest tests/unit/indexer/test_symbols.py -v`
</verification>

<success_criteria>
- PHP files indexed with functions, classes, interfaces, traits, methods as symbols
- All 10 languages (Python, JavaScript, TypeScript, Go, Rust, Java, Ruby, C, C++, PHP) extract symbols
- External query files exist for all 10 languages
- Module docstring updated to reflect all supported languages
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/34-symbol-extraction-expansion/34-04-SUMMARY.md`
</output>
