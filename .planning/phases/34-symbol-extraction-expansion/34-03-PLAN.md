---
phase: 34-symbol-extraction-expansion
plan: 03
type: execute
wave: 2
depends_on: ["34-01"]
files_modified:
  - src/cocosearch/indexer/symbols.py
  - src/cocosearch/indexer/queries/c.scm
  - src/cocosearch/indexer/queries/cpp.scm
  - tests/unit/indexer/test_symbols.py
autonomous: true

must_haves:
  truths:
    - "C files have functions, structs, enums, typedefs extracted as symbols"
    - "C++ files have functions, classes, structs, namespaces extracted as symbols"
    - "C++ method names include parent class/namespace (MyClass::myMethod)"
    - "Only function definitions (with body) are extracted, not forward declarations"
  artifacts:
    - path: "src/cocosearch/indexer/queries/c.scm"
      provides: "C symbol extraction query"
      min_lines: 10
    - path: "src/cocosearch/indexer/queries/cpp.scm"
      provides: "C++ symbol extraction query"
      min_lines: 15
    - path: "tests/unit/indexer/test_symbols.py"
      provides: "Tests for C and C++ extraction"
      contains: "test_c_"
  key_links:
    - from: "src/cocosearch/indexer/symbols.py"
      to: "LANGUAGE_MAP"
      via: "file extension mapping"
      pattern: '"c".*:.*"c"'
---

<objective>
Add C and C++ symbol extraction support using external query files.

Purpose: Extend symbol coverage to 9 languages. C and C++ are essential for systems programming codebases.

Output: Query files for C and C++, updated LANGUAGE_MAP, comprehensive tests.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/34-symbol-extraction-expansion/34-CONTEXT.md
@.planning/phases/34-symbol-extraction-expansion/34-RESEARCH.md
@.planning/phases/34-symbol-extraction-expansion/34-01-SUMMARY.md
@src/cocosearch/indexer/symbols.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add C symbol extraction</name>
  <files>
    src/cocosearch/indexer/queries/c.scm
    src/cocosearch/indexer/symbols.py
  </files>
  <action>
1. Create src/cocosearch/indexer/queries/c.scm:
```scheme
;; @doc C symbol extraction: functions, structs, enums, typedefs
;; Note: Only function_definition (with body) - not declarations

;; Functions (definitions only - have compound_statement body)
(function_definition
  declarator: (function_declarator
    declarator: (identifier) @name)) @definition.function

;; Pointer function declarators: int *foo() {}
(function_definition
  declarator: (pointer_declarator
    declarator: (function_declarator
      declarator: (identifier) @name))) @definition.function

;; Structs (with body - excludes forward declarations)
(struct_specifier
  name: (type_identifier) @name
  body: (field_declaration_list)) @definition.struct

;; Enums
(enum_specifier
  name: (type_identifier) @name) @definition.enum

;; Typedefs
(type_definition
  declarator: (type_identifier) @name) @definition.type
```

2. Update LANGUAGE_MAP in symbols.py to include C:
```python
LANGUAGE_MAP = {
    # ... existing mappings ...
    # C
    "c": "c",
    "h": "c",
}
```

3. Update container_types in _build_qualified_name() for C:
```python
container_types = {
    # ... existing ...
    "c": ["struct_specifier"],
}
```

4. Update _map_symbol_type() for C types:
```python
mapping = {
    # ... existing ...
    "struct": "class",
    "enum": "class",
    "type": "interface",  # typedef maps to interface
}
```

5. Update _build_signature() to handle C function signatures:
   - Format: `{return_type} {name}{parameters}`
   - Handle pointer return types: `int *foo()`

6. Test with sample C code:
```c
struct User {
    char *name;
    int age;
};

typedef struct User User;

enum Status {
    ACTIVE,
    INACTIVE
};

int process_user(User *user) {
    return user->age;
}

void *allocate(size_t size) {
    return malloc(size);
}
```
  </action>
  <verify>
    - `python -c "from cocosearch.indexer.symbols import extract_symbol_metadata; print(extract_symbol_metadata('int foo() { return 0; }', 'c'))"` returns function symbol
    - Forward declarations (no body) are NOT extracted
  </verify>
  <done>
    C symbol extraction working with functions, structs, enums, typedefs
  </done>
</task>

<task type="auto">
  <name>Task 2: Add C++ symbol extraction</name>
  <files>
    src/cocosearch/indexer/queries/cpp.scm
    src/cocosearch/indexer/symbols.py
  </files>
  <action>
1. Create src/cocosearch/indexer/queries/cpp.scm:
```scheme
;; @doc C++ symbol extraction: functions, classes, structs, namespaces, methods

;; Classes
(class_specifier
  name: (type_identifier) @name) @definition.class

;; Structs (with body)
(struct_specifier
  name: (type_identifier) @name
  body: (field_declaration_list)) @definition.struct

;; Namespaces
(namespace_definition
  name: (namespace_identifier) @name) @definition.namespace

;; Top-level functions
(function_definition
  declarator: (function_declarator
    declarator: (identifier) @name)) @definition.function

;; Pointer functions
(function_definition
  declarator: (pointer_declarator
    declarator: (function_declarator
      declarator: (identifier) @name))) @definition.function

;; Methods (qualified names like ClassName::method)
(function_definition
  declarator: (function_declarator
    declarator: (qualified_identifier
      name: (identifier) @name))) @definition.method

;; Template classes
(template_declaration
  (class_specifier
    name: (type_identifier) @name)) @definition.class

;; Template functions
(template_declaration
  (function_definition
    declarator: (function_declarator
      declarator: (identifier) @name))) @definition.function
```

2. Update LANGUAGE_MAP in symbols.py to include C++:
```python
LANGUAGE_MAP = {
    # ... existing mappings ...
    # C++
    "cpp": "cpp",
    "cxx": "cpp",
    "cc": "cpp",
    "hpp": "cpp",
    "hxx": "cpp",
    "hh": "cpp",
}
```

3. Update container_types in _build_qualified_name() for C++:
```python
container_types = {
    # ... existing ...
    "cpp": ["class_specifier", "struct_specifier", "namespace_definition"],
}
```

4. Use "::" as separator for C++ qualified names (already in _build_qualified_name)

5. Update _map_symbol_type() for C++ types:
```python
mapping = {
    # ... existing ...
    "namespace": "class",  # namespace maps to class
}
```

6. Update _build_signature() to handle C++ signatures:
   - Include template parameters: `template<typename T> void foo()`
   - Include const/noexcept: `void foo() const noexcept`

7. Test with sample C++ code:
```cpp
namespace MyNamespace {

class UserService {
public:
    UserService(const std::string& name);
    std::string getName() const;
private:
    std::string name_;
};

struct Point {
    int x, y;
};

template<typename T>
class Container {
    T value;
};

void helper() {
    // top-level function
}

} // namespace MyNamespace

// Method definition outside class
void MyNamespace::UserService::getName() const {
    return name_;
}
```
  </action>
  <verify>
    - `python -c "from cocosearch.indexer.symbols import extract_symbol_metadata; print(extract_symbol_metadata('class Foo {};', 'cpp'))"` returns class symbol
    - C++ method definitions have qualified names with "::" separator
  </verify>
  <done>
    C++ symbol extraction working with classes, structs, namespaces, functions, methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for C and C++ extraction</name>
  <files>
    tests/unit/indexer/test_symbols.py
  </files>
  <action>
1. Add C test cases to tests/unit/indexer/test_symbols.py:

```python
# ============================================================================
# C Tests
# ============================================================================

class TestCSymbolExtraction:
    """Test C symbol extraction."""

    def test_c_function(self):
        code = "int process() { return 0; }"
        result = extract_symbol_metadata(code, "c")
        assert result["symbol_type"] == "function"
        assert result["symbol_name"] == "process"

    def test_c_function_with_params(self):
        code = "void handle(int x, char *y) { }"
        result = extract_symbol_metadata(code, "c")
        assert result["symbol_type"] == "function"
        assert result["symbol_name"] == "handle"

    def test_c_pointer_function(self):
        code = "int *allocate(size_t n) { return NULL; }"
        result = extract_symbol_metadata(code, "c")
        assert result["symbol_type"] == "function"
        assert result["symbol_name"] == "allocate"

    def test_c_struct(self):
        code = "struct User { char *name; int age; };"
        result = extract_symbol_metadata(code, "c")
        assert result["symbol_type"] == "class"  # struct maps to class
        assert result["symbol_name"] == "User"

    def test_c_enum(self):
        code = "enum Status { ACTIVE, INACTIVE };"
        result = extract_symbol_metadata(code, "c")
        assert result["symbol_type"] == "class"  # enum maps to class
        assert result["symbol_name"] == "Status"

    def test_c_typedef(self):
        code = "typedef unsigned int uint32;"
        result = extract_symbol_metadata(code, "c")
        assert result["symbol_type"] == "interface"  # typedef maps to interface
        assert result["symbol_name"] == "uint32"

    def test_c_forward_declaration_not_extracted(self):
        """Forward declarations (no body) should not be extracted."""
        code = "void process(void);"  # declaration, not definition
        result = extract_symbol_metadata(code, "c")
        assert result["symbol_type"] is None

    def test_c_header_extension(self):
        """Header files should use C language."""
        code = "int foo() { return 1; }"
        result = extract_symbol_metadata(code, "h")
        assert result["symbol_type"] == "function"
```

2. Add C++ test cases:

```python
# ============================================================================
# C++ Tests
# ============================================================================

class TestCppSymbolExtraction:
    """Test C++ symbol extraction."""

    def test_cpp_class(self):
        code = "class UserService {};"
        result = extract_symbol_metadata(code, "cpp")
        assert result["symbol_type"] == "class"
        assert result["symbol_name"] == "UserService"

    def test_cpp_struct(self):
        code = "struct Point { int x, y; };"
        result = extract_symbol_metadata(code, "cpp")
        assert result["symbol_type"] == "class"  # struct maps to class
        assert result["symbol_name"] == "Point"

    def test_cpp_namespace(self):
        code = "namespace MyLib { }"
        result = extract_symbol_metadata(code, "cpp")
        assert result["symbol_type"] == "class"  # namespace maps to class
        assert result["symbol_name"] == "MyLib"

    def test_cpp_function(self):
        code = "void process() { }"
        result = extract_symbol_metadata(code, "cpp")
        assert result["symbol_type"] == "function"
        assert result["symbol_name"] == "process"

    def test_cpp_method_qualified(self):
        """Method definitions outside class should have qualified names."""
        code = '''
class Foo {
    void bar();
};
void Foo::bar() { }
'''
        from cocosearch.indexer.symbols import _extract_symbols_with_query, resolve_query_file
        query = resolve_query_file("cpp")
        symbols = _extract_symbols_with_query(code, "cpp", query)
        method_symbols = [s for s in symbols if s["symbol_type"] == "method"]
        # Should find Foo::bar as a method
        assert len(method_symbols) >= 1

    def test_cpp_nested_namespace(self):
        code = '''
namespace Outer {
    namespace Inner {
        class Foo {};
    }
}
'''
        from cocosearch.indexer.symbols import _extract_symbols_with_query, resolve_query_file
        query = resolve_query_file("cpp")
        symbols = _extract_symbols_with_query(code, "cpp", query)
        # Should find namespaces and class
        assert len(symbols) >= 3

    def test_cpp_template_class(self):
        code = "template<typename T> class Container {};"
        result = extract_symbol_metadata(code, "cpp")
        assert result["symbol_type"] == "class"
        assert result["symbol_name"] == "Container"

    def test_cpp_file_extensions(self):
        """All C++ extensions should work."""
        code = "class Foo {};"
        for ext in ["cpp", "cxx", "cc", "hpp"]:
            result = extract_symbol_metadata(code, ext)
            assert result["symbol_type"] == "class", f"Failed for extension: {ext}"
```

3. Run all tests: `pytest tests/unit/indexer/test_symbols.py -v`
  </action>
  <verify>
    - `pytest tests/unit/indexer/test_symbols.py::TestCSymbolExtraction -v` all pass
    - `pytest tests/unit/indexer/test_symbols.py::TestCppSymbolExtraction -v` all pass
    - `pytest tests/unit/indexer/test_symbols.py -v` full suite passes
  </verify>
  <done>
    Comprehensive tests for C and C++ symbol extraction passing
  </done>
</task>

</tasks>

<verification>
1. C: `python -c "from cocosearch.indexer.symbols import extract_symbol_metadata; print(extract_symbol_metadata('int foo() { return 0; }', 'c'))"`
2. C++: `python -c "from cocosearch.indexer.symbols import extract_symbol_metadata; print(extract_symbol_metadata('class Foo {};', 'cpp'))"`
3. Tests: `pytest tests/unit/indexer/test_symbols.py -v -k "c_ or cpp"`
</verification>

<success_criteria>
- C files indexed with functions, structs, enums, typedefs as symbols
- C++ files indexed with functions, classes, structs, namespaces as symbols
- Only definitions (with body) extracted, not forward declarations
- C++ uses "::" separator for qualified names
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/34-symbol-extraction-expansion/34-03-SUMMARY.md`
</output>
