---
phase: 25-auto-detect
plan: 02
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - src/cocosearch/mcp/server.py
autonomous: true

must_haves:
  truths:
    - "User can call search_code without index_name and system auto-detects from cwd"
    - "User receives helpful error when not in a project directory"
    - "User receives prompt to index when project detected but no index exists"
    - "User receives collision error with resolution options when same name maps to different paths"
  artifacts:
    - path: "src/cocosearch/mcp/server.py"
      provides: "MCP tool with auto-detection"
      contains: "find_project_root"
  key_links:
    - from: "src/cocosearch/mcp/server.py"
      to: "src/cocosearch/management/context.py"
      via: "import find_project_root, resolve_index_name"
      pattern: "from cocosearch.management import.*find_project_root"
    - from: "src/cocosearch/mcp/server.py"
      to: "src/cocosearch/management/metadata.py"
      via: "import get_index_metadata"
      pattern: "from cocosearch.management import.*get_index_metadata"
---

<objective>
Integrate auto-detection into MCP search_code tool, making index_name optional and providing helpful guidance when auto-detection fails or index doesn't exist.

Purpose: Enable users to search code without specifying index_name, automatically detecting the project from their working directory and guiding them through resolution when issues arise.

Output: Updated MCP server with auto-detect capability and structured error responses for all failure modes.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-auto-detect/25-CONTEXT.md
@.planning/phases/25-auto-detect/25-RESEARCH.md
@.planning/phases/25-auto-detect/25-01-SUMMARY.md
@src/cocosearch/mcp/server.py
@src/cocosearch/management/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make search_code index_name optional with auto-detection</name>
  <files>src/cocosearch/mcp/server.py</files>
  <action>
Update `src/cocosearch/mcp/server.py`:

1. Add imports at top (after existing imports):
```python
from cocosearch.management import (
    find_project_root,
    resolve_index_name,
    get_index_metadata,
)
from cocosearch.management import list_indexes as mgmt_list_indexes  # already imported, keep it
```

2. Modify search_code function signature to make index_name optional:
```python
@mcp.tool()
def search_code(
    query: Annotated[str, Field(description="Natural language search query")],
    index_name: Annotated[
        str | None,
        Field(
            description="Name of the index to search. If not provided, auto-detects from current working directory."
        ),
    ] = None,
    limit: Annotated[int, Field(description="Maximum results to return")] = 10,
    language: Annotated[
        str | None,
        Field(
            description="Filter by language (e.g., python, typescript, hcl, dockerfile, bash). "
            "Aliases: terraform=hcl, shell/sh=bash. Comma-separated for multiple."
        ),
    ] = None,
) -> list[dict]:
```

3. Add auto-detection logic at start of search_code:
```python
def search_code(...) -> list[dict]:
    """Search indexed code using natural language.

    Returns code chunks matching the query, ranked by semantic similarity.
    If index_name is not provided, auto-detects from current working directory.
    """
    # Auto-detect index if not provided
    if index_name is None:
        root_path, detection_method = find_project_root()

        if root_path is None:
            # Not in a project directory
            return [{
                "error": "No project detected",
                "message": (
                    "Not in a git repository or directory with cocosearch.yaml. "
                    "Either navigate to your project directory, or specify index_name parameter explicitly."
                ),
                "results": []
            }]

        # Resolve index name using priority chain
        index_name = resolve_index_name(root_path, detection_method)
        logger.info(f"Auto-detected index: {index_name} from {root_path}")

        # Check if index exists
        indexes = mgmt_list_indexes()
        index_names = {idx["name"] for idx in indexes}

        if index_name not in index_names:
            # Project detected but not indexed
            return [{
                "error": "Index not found",
                "message": (
                    f"Project detected at {root_path} but not indexed. "
                    f"Index this project first using:\n"
                    f"  CLI: cocosearch index {root_path}\n"
                    f"  MCP: index_codebase(path='{root_path}')"
                ),
                "detected_path": str(root_path),
                "suggested_index_name": index_name,
                "results": []
            }]

        # Check for collision (same index name, different path in metadata)
        metadata = get_index_metadata(index_name)
        if metadata is not None:
            canonical_cwd = str(root_path.resolve())
            stored_path = metadata.get("canonical_path", "")
            if stored_path and stored_path != canonical_cwd:
                # Collision detected
                return [{
                    "error": "Index name collision",
                    "message": (
                        f"Index '{index_name}' is already mapped to a different project:\n"
                        f"  Stored: {stored_path}\n"
                        f"  Current: {canonical_cwd}\n\n"
                        f"To resolve:\n"
                        f"  1. Set explicit indexName in cocosearch.yaml, or\n"
                        f"  2. Specify index_name parameter explicitly"
                    ),
                    "results": []
                }]

    # Rest of existing search logic continues unchanged...
    # Initialize CocoIndex (required for embedding generation)
    cocoindex.init()
    # ... (keep all existing search code)
```

Note: The error responses return a list with a single dict containing the error info. This matches MCP tool response patterns where the tool returns data (not raises exceptions) and the LLM interprets it.
  </action>
  <verify>
```bash
# Verify the updated server.py syntax
python -c "
from cocosearch.mcp.server import search_code, mcp
import inspect

# Check search_code signature
sig = inspect.signature(search_code)
params = list(sig.parameters.keys())
print(f'search_code params: {params}')

# Verify index_name has default None
index_param = sig.parameters['index_name']
assert index_param.default is None, 'index_name should default to None'
print('index_name default: OK')

# Check imports work
from cocosearch.management import find_project_root, resolve_index_name, get_index_metadata
print('Required imports: OK')

print('MCP server syntax check passed')
"
```
  </verify>
  <done>
- search_code accepts optional index_name parameter
- Auto-detection uses find_project_root and resolve_index_name
- Returns structured error for "no project detected" case
- Returns structured error for "index not found" case with guidance
  </done>
</task>

<task type="auto">
  <name>Task 2: Add collision detection in auto-detect flow</name>
  <files>src/cocosearch/mcp/server.py</files>
  <action>
The collision detection was included in Task 1's action. This task ensures the complete flow is tested.

Verify the collision detection logic is properly integrated:

1. When index_name is auto-detected, check get_index_metadata(index_name)
2. If metadata exists, compare stored canonical_path with current project's canonical path
3. If paths differ, return collision error with resolution guidance

Also update index_codebase tool to register path after successful indexing (this prepares for path tracking):

```python
@mcp.tool()
def index_codebase(
    path: Annotated[str, Field(description="Path to the codebase directory to index")],
    index_name: Annotated[
        str | None,
        Field(description="Name for the index (auto-derived from path if not provided)"),
    ] = None,
) -> dict:
    """Index a codebase directory for semantic search.

    Creates embeddings for all code files and stores them in the database.
    If the index already exists, it will be updated with any changes.
    """
    try:
        # Initialize CocoIndex
        cocoindex.init()

        # Derive index name if not provided
        if not index_name:
            index_name = derive_index_name(path)

        # Run indexing with default config
        update_info = run_index(
            index_name=index_name,
            codebase_path=path,
            config=IndexingConfig(),
        )

        # Register path-to-index mapping (enables collision detection)
        from cocosearch.management import register_index_path
        try:
            register_index_path(index_name, path)
        except ValueError as collision_error:
            # Collision during indexing - warn but continue (index was created)
            logger.warning(f"Path registration warning: {collision_error}")

        # Extract stats from update_info
        stats = {
            "files_added": 0,
            "files_removed": 0,
            "files_updated": 0,
        }

        if hasattr(update_info, "stats") and isinstance(update_info.stats, dict):
            file_stats = update_info.stats.get("files", {})
            stats["files_added"] = file_stats.get("num_insertions", 0)
            stats["files_removed"] = file_stats.get("num_deletions", 0)
            stats["files_updated"] = file_stats.get("num_updates", 0)

        return {
            "success": True,
            "index_name": index_name,
            "path": path,
            "stats": stats,
        }
    except Exception as e:
        return {"success": False, "error": f"Failed to index codebase: {e}"}
```

Also update clear_index tool to clear metadata:

```python
@mcp.tool()
def clear_index(
    index_name: Annotated[str, Field(description="Name of the index to delete")],
) -> dict:
    """Clear (delete) a code index.

    WARNING: This permanently deletes all indexed data for this codebase.
    The operation cannot be undone.
    """
    try:
        result = mgmt_clear_index(index_name)

        # Also clear path metadata
        from cocosearch.management import clear_index_path
        clear_index_path(index_name)

        return result
    except ValueError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        return {"success": False, "error": f"Failed to clear index: {e}"}
```
  </action>
  <verify>
```bash
# Verify complete server.py with all updates
python -c "
from cocosearch.mcp import server
import inspect

# Check all MCP tools are defined
tools = ['search_code', 'list_indexes', 'index_stats', 'clear_index', 'index_codebase']
for tool_name in tools:
    assert hasattr(server, tool_name), f'Missing tool: {tool_name}'
print('All MCP tools present: OK')

# Check search_code has auto-detect logic
source = inspect.getsource(server.search_code)
assert 'find_project_root' in source, 'search_code should use find_project_root'
assert 'resolve_index_name' in source, 'search_code should use resolve_index_name'
assert 'No project detected' in source, 'search_code should handle no project case'
assert 'Index not found' in source, 'search_code should handle missing index case'
print('Auto-detect logic in search_code: OK')

# Check index_codebase registers path
source = inspect.getsource(server.index_codebase)
assert 'register_index_path' in source, 'index_codebase should register path'
print('Path registration in index_codebase: OK')

# Check clear_index clears metadata
source = inspect.getsource(server.clear_index)
assert 'clear_index_path' in source, 'clear_index should clear metadata'
print('Metadata cleanup in clear_index: OK')

print('All MCP server updates verified')
"
```
  </verify>
  <done>
- Collision detection integrated in auto-detect flow
- index_codebase registers path-to-index mapping after successful indexing
- clear_index removes path metadata when deleting index
- All error responses include actionable guidance
  </done>
</task>

</tasks>

<verification>
1. MCP server imports without errors
2. search_code signature accepts optional index_name
3. Auto-detection logic paths are all present in source
4. Path registration happens during indexing
5. Metadata cleared during index deletion
</verification>

<success_criteria>
- search_code can be called without index_name parameter
- When not in a project, returns structured error with "No project detected"
- When in project without index, returns error with indexing instructions
- When collision detected, returns error with resolution options
- index_codebase registers path after indexing
- clear_index removes path metadata
</success_criteria>

<output>
After completion, create `.planning/phases/25-auto-detect/25-02-SUMMARY.md`
</output>
