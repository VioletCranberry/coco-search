---
phase: 25-auto-detect
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cocosearch/management/context.py
  - src/cocosearch/management/metadata.py
  - src/cocosearch/management/__init__.py
autonomous: true

must_haves:
  truths:
    - "System can detect project root from any subdirectory"
    - "System resolves symlinks to canonical paths"
    - "System follows priority chain: cocosearch.yaml indexName > git repo name > directory name"
    - "System can store and retrieve path-to-index mappings"
    - "System detects collisions when same index name maps to different path"
  artifacts:
    - path: "src/cocosearch/management/context.py"
      provides: "Project root detection and index name resolution"
      contains: "find_project_root"
    - path: "src/cocosearch/management/metadata.py"
      provides: "Path-to-index metadata storage with collision detection"
      contains: "register_index_path"
  key_links:
    - from: "src/cocosearch/management/context.py"
      to: "src/cocosearch/management/git.py"
      via: "import get_git_root"
      pattern: "from.*git.*import"
    - from: "src/cocosearch/management/metadata.py"
      to: "src/cocosearch/search/db.py"
      via: "database connection pool"
      pattern: "get_connection_pool"
---

<objective>
Create foundation modules for auto-detect feature: project root detection with priority chain resolution, and path-to-index metadata storage with collision detection.

Purpose: Enable MCP tools to automatically detect which project/index to use based on working directory, while preventing conflicts when multiple projects would derive the same index name.

Output: Two new modules (context.py, metadata.py) that provide the core auto-detection and collision detection capabilities.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-auto-detect/25-CONTEXT.md
@.planning/phases/25-auto-detect/25-RESEARCH.md
@src/cocosearch/management/git.py
@src/cocosearch/config/loader.py
@src/cocosearch/search/db.py
@src/cocosearch/cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create context detection module</name>
  <files>src/cocosearch/management/context.py, src/cocosearch/management/__init__.py</files>
  <action>
Create `src/cocosearch/management/context.py` with these functions:

1. `find_project_root(start_path: Path | None = None) -> tuple[Path | None, str | None]`
   - Walk up directory tree from start_path (default: cwd)
   - Resolve symlinks using `Path.resolve(strict=False)` BEFORE walking
   - Check for .git directory first (detection_method = "git")
   - Check for cocosearch.yaml second (detection_method = "config")
   - Walk until reaching filesystem root (current == current.parent)
   - Return (canonical_root_path, detection_method) or (None, None)

2. `get_canonical_path(path: str | Path) -> Path`
   - Simple wrapper: `return Path(path).resolve(strict=False)`
   - Used for consistent symlink resolution

3. `resolve_index_name(project_root: Path, detection_method: str | None) -> str`
   - Priority 1: Load cocosearch.yaml from project_root, check indexName field
   - Priority 2: Use derive_index_name from cli.py on project_root
   - Import derive_index_name at function level to avoid circular imports
   - Load config using load_config from cocosearch.config (handles missing file gracefully)

Update `src/cocosearch/management/__init__.py` to export:
- find_project_root
- get_canonical_path
- resolve_index_name

Implementation notes:
- Use pathlib.Path throughout (not os.path)
- Do NOT catch exceptions in find_project_root - let filesystem errors propagate
- For config loading, use try/except ConfigError to handle invalid configs gracefully (fall back to directory name)
  </action>
  <verify>
```bash
python -c "
from cocosearch.management import find_project_root, get_canonical_path, resolve_index_name
from pathlib import Path

# Test get_canonical_path
p = get_canonical_path('.')
print(f'Canonical path: {p}')
assert p.is_absolute(), 'Path should be absolute'

# Test find_project_root (in cocosearch repo which has .git)
root, method = find_project_root()
print(f'Project root: {root}, method: {method}')
assert root is not None, 'Should find project root'
assert method == 'git', 'Should detect via git'

# Test resolve_index_name
name = resolve_index_name(root, method)
print(f'Resolved index name: {name}')
assert name, 'Should return non-empty name'

print('All context detection tests passed')
"
```
  </verify>
  <done>
- find_project_root correctly walks up directory tree and detects .git or cocosearch.yaml
- get_canonical_path resolves symlinks to absolute paths
- resolve_index_name follows priority chain (config indexName > directory name)
- All functions are exported from cocosearch.management
  </done>
</task>

<task type="auto">
  <name>Task 2: Create metadata storage module with collision detection</name>
  <files>src/cocosearch/management/metadata.py, src/cocosearch/management/__init__.py</files>
  <action>
Create `src/cocosearch/management/metadata.py` with these functions:

1. `ensure_metadata_table() -> None`
   - Create table if not exists:
     ```sql
     CREATE TABLE IF NOT EXISTS cocosearch_index_metadata (
         index_name TEXT PRIMARY KEY,
         canonical_path TEXT NOT NULL,
         created_at TIMESTAMP DEFAULT NOW(),
         updated_at TIMESTAMP DEFAULT NOW()
     );
     CREATE INDEX IF NOT EXISTS idx_cocosearch_metadata_path
         ON cocosearch_index_metadata(canonical_path);
     ```
   - Use get_connection_pool() from search.db
   - Commit after creating

2. `get_index_metadata(index_name: str) -> dict | None`
   - Query metadata table for index_name
   - Return dict with keys: index_name, canonical_path, created_at, updated_at
   - Return None if not found

3. `get_index_for_path(canonical_path: str) -> str | None`
   - Query metadata table by canonical_path
   - Return index_name if found, None otherwise
   - Use functools.lru_cache(maxsize=128) for caching
   - Cache key is the canonical_path string

4. `register_index_path(index_name: str, project_path: str | Path) -> None`
   - Resolve project_path to canonical form using get_canonical_path
   - Call ensure_metadata_table() first
   - Check for collision: existing entry with same index_name but different path
   - On collision, raise ValueError with helpful message:
     ```
     Index name collision detected: '{index_name}'
       Existing path: {existing_path}
       New path: {canonical_path}

     To resolve:
       1. Set explicit indexName in cocosearch.yaml at {project_path}, or
       2. Use --index-name flag: cocosearch index {project_path} --name <unique-name>
     ```
   - If no collision, upsert: INSERT ... ON CONFLICT (index_name) DO UPDATE SET canonical_path = ..., updated_at = NOW()
   - Clear lru_cache after successful upsert: get_index_for_path.cache_clear()

5. `clear_index_path(index_name: str) -> bool`
   - Delete from metadata table where index_name matches
   - Return True if row deleted, False if not found
   - Clear lru_cache after deletion

Update `src/cocosearch/management/__init__.py` to export:
- ensure_metadata_table
- get_index_metadata
- get_index_for_path
- register_index_path
- clear_index_path

Implementation notes:
- All database operations use context manager: `with pool.connection() as conn`
- Commit explicitly after write operations
- Use TEXT type for paths (not VARCHAR) per research recommendations
- The lru_cache on get_index_for_path is critical for performance since MCP tools call this frequently
  </action>
  <verify>
```bash
# This test requires DATABASE_URL to be set
python -c "
from cocosearch.management import (
    ensure_metadata_table,
    get_index_metadata,
    get_index_for_path,
    register_index_path,
    clear_index_path,
)
from pathlib import Path
import os

# Skip if no database configured
if not os.getenv('COCOSEARCH_DATABASE_URL'):
    print('COCOSEARCH_DATABASE_URL not set, skipping database tests')
    exit(0)

# Test ensure_metadata_table (idempotent)
ensure_metadata_table()
ensure_metadata_table()  # Should not fail
print('ensure_metadata_table: OK')

# Test register and retrieve
test_name = '_test_autodetect_plan01'
test_path = '/tmp/test_project'
register_index_path(test_name, test_path)
print('register_index_path: OK')

metadata = get_index_metadata(test_name)
assert metadata is not None, 'Should find registered metadata'
assert metadata['canonical_path'] == Path(test_path).resolve(strict=False).as_posix() or metadata['canonical_path'] == str(Path(test_path).resolve(strict=False))
print('get_index_metadata: OK')

# Test collision detection
try:
    register_index_path(test_name, '/tmp/different_project')
    print('ERROR: Should have raised ValueError for collision')
    exit(1)
except ValueError as e:
    assert 'collision' in str(e).lower()
    print('Collision detection: OK')

# Cleanup
clear_index_path(test_name)
assert get_index_metadata(test_name) is None
print('clear_index_path: OK')

print('All metadata storage tests passed')
"
```
  </verify>
  <done>
- Metadata table is created with proper schema (TEXT columns, timestamps)
- register_index_path stores canonical path and detects collisions
- get_index_for_path retrieves index name for a path with caching
- clear_index_path removes metadata entries
- Cache is properly invalidated after writes
  </done>
</task>

</tasks>

<verification>
1. Both modules exist and are importable
2. Context detection finds project root in cocosearch repo
3. Metadata storage operations work with real database
4. Collision detection raises appropriate error
5. No import errors or circular dependencies
</verification>

<success_criteria>
- find_project_root returns (path, "git") when run from cocosearch directory
- resolve_index_name returns "coco_s" or similar for cocosearch repo
- Metadata table exists in database after first operation
- Collision detection prevents overwriting different project paths
- All functions exported from cocosearch.management
</success_criteria>

<output>
After completion, create `.planning/phases/25-auto-detect/25-01-SUMMARY.md`
</output>
