---
phase: 35-stats-dashboard
plan: 03
type: execute
wave: 3
depends_on: ["35-02"]
files_modified:
  - src/cocosearch/mcp/server.py
  - src/cocosearch/dashboard/web/__init__.py
  - src/cocosearch/dashboard/web/static/index.html
  - src/cocosearch/cli.py
autonomous: false

must_haves:
  truths:
    - "User can access web dashboard at /dashboard URL"
    - "Web dashboard shows index stats with Chart.js bar charts"
    - "Web dashboard supports dark and light mode"
    - "Web dashboard fetches data from /api/stats endpoint"
    - "cocosearch serve-dashboard starts standalone dashboard server"
  artifacts:
    - path: "src/cocosearch/dashboard/web/static/index.html"
      provides: "Single-page web dashboard with embedded CSS/JS"
      contains: "chart.js"
    - path: "src/cocosearch/mcp/server.py"
      provides: "/dashboard route serving HTML"
      contains: "/dashboard"
    - path: "src/cocosearch/cli.py"
      provides: "serve-dashboard command"
      contains: "serve-dashboard"
  key_links:
    - from: "src/cocosearch/dashboard/web/static/index.html"
      to: "/api/stats"
      via: "fetch() call"
      pattern: "fetch.*api/stats"
    - from: "src/cocosearch/mcp/server.py"
      to: "src/cocosearch/dashboard/web/static/index.html"
      via: "HTMLResponse serving"
      pattern: "HTMLResponse"
---

<objective>
Create a browser-accessible web dashboard at /dashboard with Chart.js visualizations, dark/light mode support, and a standalone serve-dashboard CLI command.

Purpose: Provide a Grafana-like dense data visualization interface for users who prefer browser-based monitoring of index health.

Output: Single-page HTML dashboard with embedded CSS/JS using Chart.js CDN; /dashboard route in MCP server; serve-dashboard CLI command for standalone operation.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/35-stats-dashboard/35-CONTEXT.md
@.planning/phases/35-stats-dashboard/35-RESEARCH.md
@.planning/phases/35-stats-dashboard/35-01-SUMMARY.md
@.planning/phases/35-stats-dashboard/35-02-SUMMARY.md

@src/cocosearch/mcp/server.py
@src/cocosearch/cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create web dashboard HTML with Chart.js</name>
  <files>
src/cocosearch/dashboard/web/__init__.py
src/cocosearch/dashboard/web/static/index.html
  </files>
  <action>
Create the web dashboard static files:

1. Create src/cocosearch/dashboard/web/__init__.py:
   ```python
   """Web dashboard module for cocosearch.

   Provides browser-based dashboard with Chart.js visualizations.
   """

   from pathlib import Path

   STATIC_DIR = Path(__file__).parent / "static"


   def get_dashboard_html() -> str:
       """Return the dashboard HTML content."""
       html_path = STATIC_DIR / "index.html"
       return html_path.read_text()
   ```

2. Create src/cocosearch/dashboard/web/static/index.html with:

   - Grafana-like dense layout (per CONTEXT.md)
   - Chart.js via CDN for bar charts
   - Auto-detect dark/light mode via prefers-color-scheme
   - Fetch stats from /api/stats endpoint
   - Summary cards at top
   - Language distribution bar chart
   - Symbol type bar chart
   - Warning banner (if any warnings)
   - Expandable index selector (for multi-index)

   Structure:
   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>CocoSearch Dashboard</title>
       <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
       <style>
           /* CSS variables for theming */
           :root {
               --bg-primary: #ffffff;
               --bg-secondary: #f5f5f5;
               --text-primary: #1a1a1a;
               --text-secondary: #666666;
               --border-color: #e0e0e0;
               --warning-bg: #fff3cd;
               --warning-text: #856404;
               --chart-color-1: rgba(54, 162, 235, 0.8);
               --chart-color-2: rgba(153, 102, 255, 0.8);
           }

           @media (prefers-color-scheme: dark) {
               :root {
                   --bg-primary: #1a1a1a;
                   --bg-secondary: #2d2d2d;
                   --text-primary: #ffffff;
                   --text-secondary: #a0a0a0;
                   --border-color: #404040;
                   --warning-bg: #332701;
                   --warning-text: #ffc107;
               }
           }

           * { box-sizing: border-box; margin: 0; padding: 0; }
           body {
               font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
               background: var(--bg-primary);
               color: var(--text-primary);
               line-height: 1.5;
               padding: 1rem;
           }

           .header {
               display: flex;
               justify-content: space-between;
               align-items: center;
               margin-bottom: 1rem;
               padding-bottom: 1rem;
               border-bottom: 1px solid var(--border-color);
           }

           .header h1 { font-size: 1.5rem; }

           .index-select {
               padding: 0.5rem;
               background: var(--bg-secondary);
               border: 1px solid var(--border-color);
               border-radius: 4px;
               color: var(--text-primary);
           }

           .warning-banner {
               background: var(--warning-bg);
               color: var(--warning-text);
               padding: 1rem;
               border-radius: 4px;
               margin-bottom: 1rem;
           }

           .warning-banner ul { margin-left: 1.5rem; }

           .stats-grid {
               display: grid;
               grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
               gap: 1rem;
               margin-bottom: 1.5rem;
           }

           .stat-card {
               background: var(--bg-secondary);
               padding: 1rem;
               border-radius: 8px;
               text-align: center;
           }

           .stat-card .value {
               font-size: 2rem;
               font-weight: bold;
               color: var(--text-primary);
           }

           .stat-card .label {
               font-size: 0.875rem;
               color: var(--text-secondary);
           }

           .charts-grid {
               display: grid;
               grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
               gap: 1.5rem;
           }

           .chart-container {
               background: var(--bg-secondary);
               padding: 1rem;
               border-radius: 8px;
           }

           .chart-container h3 {
               margin-bottom: 1rem;
               font-size: 1rem;
               color: var(--text-secondary);
           }

           .loading { text-align: center; padding: 2rem; color: var(--text-secondary); }
           .error { color: #dc3545; padding: 2rem; text-align: center; }

           .timestamp {
               text-align: right;
               font-size: 0.75rem;
               color: var(--text-secondary);
               margin-top: 1rem;
           }
       </style>
   </head>
   <body>
       <div class="header">
           <h1>CocoSearch Dashboard</h1>
           <select id="indexSelect" class="index-select">
               <option value="">Loading...</option>
           </select>
       </div>

       <div id="warnings" class="warning-banner" style="display: none;"></div>

       <div id="loading" class="loading">Loading stats...</div>
       <div id="error" class="error" style="display: none;"></div>

       <div id="content" style="display: none;">
           <div class="stats-grid">
               <div class="stat-card">
                   <div id="fileCount" class="value">-</div>
                   <div class="label">Files</div>
               </div>
               <div class="stat-card">
                   <div id="chunkCount" class="value">-</div>
                   <div class="label">Chunks</div>
               </div>
               <div class="stat-card">
                   <div id="storageSize" class="value">-</div>
                   <div class="label">Size</div>
               </div>
               <div class="stat-card">
                   <div id="lastUpdate" class="value">-</div>
                   <div class="label">Last Update</div>
               </div>
           </div>

           <div class="charts-grid">
               <div class="chart-container">
                   <h3>Language Distribution</h3>
                   <canvas id="languageChart"></canvas>
               </div>
               <div class="chart-container">
                   <h3>Symbol Types</h3>
                   <canvas id="symbolChart"></canvas>
               </div>
           </div>

           <div class="timestamp">
               Last refreshed: <span id="refreshTime">-</span>
           </div>
       </div>

       <script>
           let languageChart = null;
           let symbolChart = null;
           let allStats = [];

           const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
           Chart.defaults.color = isDark ? '#a0a0a0' : '#666666';

           async function loadStats() {
               try {
                   const response = await fetch('/api/stats');
                   if (!response.ok) throw new Error('Failed to fetch stats');
                   allStats = await response.json();

                   // Populate index selector
                   const select = document.getElementById('indexSelect');
                   select.innerHTML = allStats.map(s =>
                       `<option value="${s.name}">${s.name}</option>`
                   ).join('');

                   if (allStats.length > 0) {
                       displayStats(allStats[0]);
                   }

                   document.getElementById('loading').style.display = 'none';
                   document.getElementById('content').style.display = 'block';
               } catch (err) {
                   document.getElementById('loading').style.display = 'none';
                   document.getElementById('error').textContent = err.message;
                   document.getElementById('error').style.display = 'block';
               }
           }

           function displayStats(stats) {
               // Summary cards
               document.getElementById('fileCount').textContent = stats.file_count.toLocaleString();
               document.getElementById('chunkCount').textContent = stats.chunk_count.toLocaleString();
               document.getElementById('storageSize').textContent = stats.storage_size_pretty;

               if (stats.updated_at) {
                   const days = stats.staleness_days;
                   document.getElementById('lastUpdate').textContent = days >= 0 ? `${days}d ago` : 'N/A';
               } else {
                   document.getElementById('lastUpdate').textContent = 'N/A';
               }

               // Warnings
               const warningsEl = document.getElementById('warnings');
               if (stats.warnings && stats.warnings.length > 0) {
                   warningsEl.innerHTML = '<strong>Warnings:</strong><ul>' +
                       stats.warnings.map(w => `<li>${w}</li>`).join('') + '</ul>';
                   warningsEl.style.display = 'block';
               } else {
                   warningsEl.style.display = 'none';
               }

               // Language chart
               const langLabels = stats.languages.slice(0, 10).map(l => l.language);
               const langData = stats.languages.slice(0, 10).map(l => l.chunk_count);

               if (languageChart) languageChart.destroy();
               languageChart = new Chart(document.getElementById('languageChart'), {
                   type: 'bar',
                   data: {
                       labels: langLabels,
                       datasets: [{
                           label: 'Chunks',
                           data: langData,
                           backgroundColor: 'rgba(54, 162, 235, 0.8)',
                           borderRadius: 4,
                       }]
                   },
                   options: {
                       responsive: true,
                       indexAxis: 'y',
                       plugins: { legend: { display: false } },
                       scales: { x: { beginAtZero: true } }
                   }
               });

               // Symbol chart
               const symLabels = Object.keys(stats.symbols || {});
               const symData = Object.values(stats.symbols || {});

               if (symbolChart) symbolChart.destroy();
               if (symLabels.length > 0) {
                   symbolChart = new Chart(document.getElementById('symbolChart'), {
                       type: 'bar',
                       data: {
                           labels: symLabels,
                           datasets: [{
                               label: 'Count',
                               data: symData,
                               backgroundColor: 'rgba(153, 102, 255, 0.8)',
                               borderRadius: 4,
                           }]
                       },
                       options: {
                           responsive: true,
                           plugins: { legend: { display: false } },
                           scales: { y: { beginAtZero: true } }
                       }
                   });
               }

               // Refresh timestamp
               document.getElementById('refreshTime').textContent = new Date().toLocaleTimeString();
           }

           document.getElementById('indexSelect').addEventListener('change', (e) => {
               const stats = allStats.find(s => s.name === e.target.value);
               if (stats) displayStats(stats);
           });

           loadStats();
       </script>
   </body>
   </html>
   ```
  </action>
  <verify>
Run: `python -c "from cocosearch.dashboard.web import get_dashboard_html; print(len(get_dashboard_html()))"`
Expected: Prints a number > 5000 (HTML content length)
  </verify>
  <done>
Web dashboard HTML file exists with Chart.js integration, dark/light mode support, summary cards, language chart, symbol chart, and warning banner.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add /dashboard route to MCP server</name>
  <files>src/cocosearch/mcp/server.py</files>
  <action>
Add /dashboard route to serve the web dashboard:

1. Import web dashboard module:
   ```python
   from cocosearch.dashboard.web import get_dashboard_html
   ```

2. Add static file routes for dashboard:
   ```python
   from starlette.responses import HTMLResponse

   @mcp.custom_route("/dashboard", methods=["GET"])
   async def serve_dashboard(request):
       """Serve the web dashboard HTML."""
       html_content = get_dashboard_html()
       return HTMLResponse(content=html_content)
   ```

3. Update existing /health endpoint docstring to mention /dashboard:
   ```python
   @mcp.custom_route("/health", methods=["GET"])
   async def health_check(request):
       """Health check endpoint. Also see /dashboard for web UI."""
       return JSONResponse({"status": "ok"})
   ```
  </action>
  <verify>
Start MCP server: `cocosearch mcp --transport sse --port 3001 &`
Then: `curl -s http://localhost:3001/dashboard | head -5`
Expected: Returns HTML starting with `<!DOCTYPE html>`
  </verify>
  <done>
/dashboard route serves web dashboard HTML. Page loads in browser with Chart.js visualizations.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add serve-dashboard CLI command</name>
  <files>src/cocosearch/cli.py</files>
  <action>
Add standalone dashboard server command:

1. Add serve-dashboard subparser:
   ```python
   # Serve-dashboard subcommand
   serve_parser = subparsers.add_parser(
       "serve-dashboard",
       help="Start standalone web dashboard server",
       description="Start a web server to view the stats dashboard in a browser.",
   )
   serve_parser.add_argument(
       "--port", "-p",
       type=int,
       default=8080,
       help="Port to serve dashboard on (default: 8080)",
   )
   serve_parser.add_argument(
       "--host",
       default="127.0.0.1",
       help="Host to bind to (default: 127.0.0.1)",
   )
   ```

2. Add serve_dashboard_command function:
   ```python
   def serve_dashboard_command(args: argparse.Namespace) -> int:
       """Execute the serve-dashboard command.

       Starts a minimal HTTP server serving the web dashboard and API.
       """
       from cocosearch.mcp import run_server

       console = Console()
       console.print(f"[bold]Starting CocoSearch Dashboard[/bold]")
       console.print(f"  Dashboard: http://{args.host}:{args.port}/dashboard")
       console.print(f"  API: http://{args.host}:{args.port}/api/stats")
       console.print()
       console.print("[dim]Press Ctrl+C to stop[/dim]")

       # Use MCP server with SSE transport (provides HTTP routes)
       try:
           run_server(transport="sse", host=args.host, port=args.port)
           return 0
       except KeyboardInterrupt:
           console.print("\n[dim]Dashboard stopped[/dim]")
           return 0
       except OSError as e:
           if "Address already in use" in str(e):
               console.print(f"[bold red]Error:[/bold red] Port {args.port} is already in use")
               return 1
           raise
   ```

3. Add to command routing:
   ```python
   elif args.command == "serve-dashboard":
       sys.exit(serve_dashboard_command(args))
   ```

4. Add to known_subcommands:
   ```python
   known_subcommands = ("index", "search", "list", "stats", "languages", "clear", "init", "mcp", "config", "serve-dashboard", "-h", "--help")
   ```
  </action>
  <verify>
Run: `cocosearch serve-dashboard --help`
Expected: Shows --port and --host flags

Run: `cocosearch serve-dashboard --port 8080 &` then `curl http://localhost:8080/dashboard | head -1`
Expected: Returns `<!DOCTYPE html>`
  </verify>
  <done>
`cocosearch serve-dashboard` command starts web server. Dashboard accessible at http://host:port/dashboard. API accessible at http://host:port/api/stats.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete stats dashboard system: enhanced CLI with bar charts and warnings, terminal dashboard with multi-pane layout, HTTP API at /api/stats, and web UI at /dashboard</what-built>
  <how-to-verify>
1. Test CLI: `cocosearch stats cocosearch` — should show warning banner (if stale), summary with timestamps, language distribution with Unicode bars
2. Test CLI verbose: `cocosearch stats cocosearch -v` — should additionally show symbol type counts
3. Test CLI JSON: `cocosearch stats cocosearch --json` — should output machine-readable JSON
4. Test terminal dashboard: `cocosearch stats cocosearch --live` — should show multi-pane layout
5. Start web server: `cocosearch serve-dashboard --port 8080`
6. Open browser: http://localhost:8080/dashboard
   - Should see summary cards (files, chunks, size, last update)
   - Should see language distribution bar chart
   - Should see symbol types bar chart
   - Should auto-detect dark/light mode from system preference
   - Should be able to switch indexes via dropdown
7. Test API directly: `curl http://localhost:8080/api/stats`
   - Should return JSON array of all indexes
  </how-to-verify>
  <resume-signal>Type "approved" if all interfaces work correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. Web dashboard loads at /dashboard URL
2. Chart.js charts render correctly (language + symbols)
3. Dark/light mode works based on system preference
4. Index selector dropdown switches between indexes
5. Warning banner appears when index has warnings
6. `cocosearch serve-dashboard` starts standalone server
7. All three interfaces (CLI, terminal, web) show consistent data
</verification>

<success_criteria>
- Web dashboard accessible at /dashboard
- Charts render language and symbol distributions
- Dark mode activates automatically based on system preference
- Index selector works for multi-index installations
- Standalone serve-dashboard command works
- Dashboard fetches data from /api/stats successfully
- Visual verification confirms Grafana-like density
</success_criteria>

<output>
After completion, create `.planning/phases/35-stats-dashboard/35-03-SUMMARY.md`
</output>
