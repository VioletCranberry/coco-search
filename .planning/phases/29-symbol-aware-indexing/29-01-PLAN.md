---
phase: 29-symbol-aware-indexing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/cocosearch/indexer/symbols.py
  - tests/unit/indexer/test_symbols.py
autonomous: true

must_haves:
  truths:
    - "Tree-sitter extracts function names from Python code"
    - "Tree-sitter extracts class names from Python code"
    - "Tree-sitter extracts method names with qualified names (ClassName.method)"
    - "Decorated functions are extracted (not missed)"
    - "Nested functions are skipped (implementation details)"
    - "Parse errors return NULL fields without crashing"
  artifacts:
    - path: "pyproject.toml"
      provides: "tree-sitter dependencies"
      contains: "tree-sitter"
    - path: "src/cocosearch/indexer/symbols.py"
      provides: "Symbol extraction module"
      exports: ["extract_symbol_metadata"]
    - path: "tests/unit/indexer/test_symbols.py"
      provides: "Unit tests for symbol extraction"
      min_lines: 100
  key_links:
    - from: "src/cocosearch/indexer/symbols.py"
      to: "tree-sitter-languages"
      via: "Language import"
      pattern: "tree_sitter_python"
---

<objective>
Create the symbol extraction module using tree-sitter to parse Python code and extract function, class, and method definitions.

Purpose: Establish the foundational symbol extraction capability that will be integrated into the indexing flow (Plan 02). This module provides the core logic for identifying symbols in Python source code.

Output: A standalone `symbols.py` module with comprehensive unit tests validating extraction behavior for all symbol types.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 29 context and research
@.planning/phases/29-symbol-aware-indexing/29-CONTEXT.md
@.planning/phases/29-symbol-aware-indexing/29-RESEARCH.md

# Existing patterns for transform functions
@src/cocosearch/indexer/tsvector.py
@src/cocosearch/handlers/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tree-sitter dependencies</name>
  <files>pyproject.toml</files>
  <action>
Add tree-sitter and tree-sitter-languages to the project dependencies:

```toml
dependencies = [
    # ... existing deps ...
    "tree-sitter>=0.25.2",
    "tree-sitter-languages>=1.10.2",
]
```

Run `uv sync` to install the dependencies after updating pyproject.toml.

Note: tree-sitter-languages provides pre-compiled grammars for Python and other languages, avoiding any build step.
  </action>
  <verify>
Run: `uv run python -c "import tree_sitter; import tree_sitter_languages; print('OK')"`
Should print "OK" without errors.
  </verify>
  <done>Dependencies installed and importable</done>
</task>

<task type="auto">
  <name>Task 2: Create symbol extraction module</name>
  <files>src/cocosearch/indexer/symbols.py</files>
  <action>
Create `src/cocosearch/indexer/symbols.py` implementing tree-sitter based symbol extraction.

Key implementation details from CONTEXT.md decisions:
- Extract functions, classes, and class methods as symbols
- Use qualified names for methods: "MyClass.do_thing" not "do_thing"
- Skip nested functions (functions inside functions)
- Decorators captured but don't change symbol_type
- Async keyword included in signature: "async def fetch(url: str) -> Response"
- Parse errors return NULL fields (silent by default, log in verbose mode)

Structure:
1. Initialize tree-sitter parser (module-level, lazy initialization)
2. Define tree-sitter queries for function_definition, class_definition, decorated_definition
3. Create `extract_symbol_metadata(text: str, language: str) -> dict` function
   - Input: chunk text and language identifier
   - Output: {"symbol_type": str|None, "symbol_name": str|None, "symbol_signature": str|None}
4. Handle multiple symbols in chunk by returning the first/primary symbol
5. Handle parse errors gracefully (return NULLs, don't crash)

Mark as @cocoindex.op.function() for integration with CocoIndex flow.

Signature format per CONTEXT.md:
- Functions: "def process(self, data: list[str], limit: int = 10) -> dict"
- Async functions: "async def fetch(url: str) -> Response"
- Classes: "class MyClass(BaseClass, Mixin):"
- Decorators excluded from signature string

Symbol types to extract:
- "function" - standalone functions (not inside classes)
- "class" - class definitions
- "method" - functions inside classes (with qualified name)
  </action>
  <verify>
Run: `uv run python -c "from cocosearch.indexer.symbols import extract_symbol_metadata; print(extract_symbol_metadata('def foo(): pass', 'py'))"`
Should print: {"symbol_type": "function", "symbol_name": "foo", "symbol_signature": "def foo()"}
  </verify>
  <done>Symbol extraction module created with tree-sitter queries for Python</done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for symbol extraction</name>
  <files>tests/unit/indexer/test_symbols.py</files>
  <action>
Create comprehensive unit tests for symbol extraction in `tests/unit/indexer/test_symbols.py`.

Test cases to cover (per CONTEXT.md decisions):

**Function extraction:**
- Simple function: `def foo(): pass`
- Function with parameters: `def bar(x, y=10): pass`
- Function with type hints: `def baz(x: int) -> str: return ""`
- Async function: `async def fetch(url: str) -> Response: pass`
- Decorated function: `@property\ndef name(self): pass` (should be extracted, decorator excluded from signature)

**Class extraction:**
- Simple class: `class Foo: pass`
- Class with base: `class Bar(Foo): pass`
- Class with multiple bases: `class Baz(Foo, Mixin): pass`

**Method extraction:**
- Method inside class: should have symbol_type="method", symbol_name="ClassName.method_name"
- @classmethod: symbol_type="method"
- @staticmethod: symbol_type="method"
- @property: symbol_type="method"

**Nested functions (should be SKIPPED):**
- Function inside function: inner function should NOT appear as symbol
- Helper functions inside methods: should NOT appear

**Edge cases:**
- Chunk with no symbols: returns NULL fields
- Chunk with multiple symbols: returns first/primary symbol
- Parse errors: returns NULL fields without raising
- Non-Python language: returns NULL fields (only Python implemented in Phase 29)

**Empty/invalid input:**
- Empty string
- Whitespace only
- Syntax errors (partial code)

Use pytest markers: @pytest.mark.unit
  </action>
  <verify>
Run: `uv run pytest tests/unit/indexer/test_symbols.py -v`
All tests should pass.
  </verify>
  <done>Unit tests cover all symbol types, edge cases, and error handling</done>
</task>

</tasks>

<verification>
1. Dependencies: `uv run python -c "import tree_sitter_languages; print('tree-sitter OK')"`
2. Module import: `uv run python -c "from cocosearch.indexer.symbols import extract_symbol_metadata"`
3. Basic extraction: `uv run python -c "from cocosearch.indexer.symbols import extract_symbol_metadata; r = extract_symbol_metadata('class Foo:\n  def bar(self): pass', 'py'); print(r)"`
4. Unit tests: `uv run pytest tests/unit/indexer/test_symbols.py -v`
</verification>

<success_criteria>
- tree-sitter and tree-sitter-languages dependencies added to pyproject.toml
- symbols.py module extracts function, class, and method symbols from Python code
- Methods have qualified names (ClassName.method_name)
- Nested functions are not extracted
- Parse errors don't crash, return NULL fields
- All unit tests pass (15+ test cases)
</success_criteria>

<output>
After completion, create `.planning/phases/29-symbol-aware-indexing/29-01-SUMMARY.md`
</output>
