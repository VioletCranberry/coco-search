---
phase: 28-hybrid-search-query
plan: 04
type: execute
wave: 3
depends_on: ["28-02", "28-03"]
files_modified:
  - tests/integration/test_hybrid_search_e2e.py
  - src/cocosearch/search/__init__.py
autonomous: true

must_haves:
  truths:
    - "Hybrid search returns results from both vector and keyword sources"
    - "RRF fusion correctly ranks double-matches higher"
    - "Auto-detection triggers hybrid for camelCase/snake_case queries"
    - "Graceful degradation works for pre-v1.7 indexes"
  artifacts:
    - path: "tests/integration/test_hybrid_search_e2e.py"
      provides: "Integration tests for full hybrid search flow"
      min_lines: 80
    - path: "src/cocosearch/search/__init__.py"
      provides: "Module exports including hybrid search"
      contains: "hybrid"
  key_links:
    - from: "tests/integration/test_hybrid_search_e2e.py"
      to: "src/cocosearch/search/query.py"
      via: "search() call with use_hybrid"
      pattern: "search\\(.*use_hybrid"
---

<objective>
Integration tests and module wiring for hybrid search.

Purpose: Validate the complete hybrid search flow works end-to-end with real database queries, and ensure proper module exports.

Output:
- Integration tests for hybrid search with real PostgreSQL
- Updated __init__.py exports
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/28-hybrid-search-query/28-CONTEXT.md
@.planning/phases/28-hybrid-search-query/28-02-SUMMARY.md
@.planning/phases/28-hybrid-search-query/28-03-SUMMARY.md

Key existing code:
@tests/integration/test_hybrid_schema.py (example integration test pattern)
@src/cocosearch/search/__init__.py (update exports)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update search module exports</name>
  <files>src/cocosearch/search/__init__.py</files>
  <action>
Update the search module __init__.py to export new hybrid search components.

Add exports:
```python
from cocosearch.search.hybrid import (
    hybrid_search,
    rrf_fusion,
    execute_keyword_search,
    HybridSearchResult,
)
from cocosearch.search.query_analyzer import (
    has_identifier_pattern,
    normalize_query_for_keyword,
)
```

Update __all__ list to include new exports (if __all__ exists).

Verify existing exports are not broken:
- search (from query.py)
- SearchResult (from query.py)
- byte_to_line, read_chunk_content (from existing)
  </action>
  <verify>
Test imports work:
```bash
uv run python -c "from cocosearch.search import hybrid_search, has_identifier_pattern, HybridSearchResult; print('OK')"
```
  </verify>
  <done>
All hybrid search components exported from cocosearch.search module.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for hybrid search</name>
  <files>tests/integration/test_hybrid_search_e2e.py</files>
  <action>
Create integration tests that verify hybrid search works with real PostgreSQL.

Test setup:
- Use existing postgres_container fixture from conftest.py
- Create test table with content_text and content_tsv columns (v1.7 schema)
- Insert test data with known identifiers (getUserById, get_user_by_id)

Test cases:

1. test_hybrid_search_finds_semantic_match:
   - Insert chunk with "authentication handler" content
   - Search "login authentication"
   - Verify result found via semantic similarity
   - Verify match_type is "semantic"

2. test_hybrid_search_finds_keyword_match:
   - Insert chunk with "getUserById" function
   - Search "getUserById" (exact match)
   - Verify result found via keyword search
   - Verify match_type includes "keyword" (could be "both")

3. test_hybrid_search_ranks_double_match_higher:
   - Insert two chunks: one matching vector only, one matching both
   - Search query that should match both ways for one chunk
   - Verify "both" match ranks higher than single-source match

4. test_auto_hybrid_triggered_for_camelcase:
   - Insert chunk with "processUserData" function
   - Search "processUserData" with use_hybrid=None (auto)
   - Verify hybrid search was triggered (match_type is "keyword" or "both")

5. test_auto_hybrid_not_triggered_for_plain_english:
   - Insert chunk with "process user data" comment
   - Search "process user data" with use_hybrid=None (auto)
   - Verify vector-only search used (match_type empty or "semantic")

6. test_graceful_degradation_pre_v17_schema:
   - Create table WITHOUT content_text/content_tsv columns
   - Attempt hybrid search with use_hybrid=True
   - Verify falls back to vector-only without error
   - Verify results still returned

Use pytest markers:
```python
@pytest.mark.integration
@pytest.mark.requires_postgres
```
  </action>
  <verify>
Run integration tests (requires Docker):
```bash
uv run pytest tests/integration/test_hybrid_search_e2e.py -v --tb=short
```

If no Docker available, tests should skip gracefully.
  </verify>
  <done>
Integration tests verify complete hybrid search flow with real PostgreSQL, all scenarios covered.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. Run unit tests: `uv run pytest tests/unit/ -v -k "hybrid or query_analyzer"`
2. Run integration tests: `uv run pytest tests/integration/test_hybrid_search_e2e.py -v`
3. Run full test suite to check no regressions: `uv run pytest tests/ -v`
</verification>

<success_criteria>
- All hybrid search components properly exported from search module
- Integration tests pass with real PostgreSQL
- RRF fusion correctly ranks double-matches higher
- Auto-detection works for identifier patterns
- Graceful degradation verified for pre-v1.7 indexes
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/28-hybrid-search-query/28-04-SUMMARY.md`
</output>
