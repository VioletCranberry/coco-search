---
phase: 28-hybrid-search-query
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cocosearch/search/hybrid.py
  - src/cocosearch/search/query_analyzer.py
  - tests/unit/test_hybrid_search.py
  - tests/unit/test_query_analyzer.py
autonomous: true

must_haves:
  truths:
    - "RRF fusion correctly combines vector and keyword scores into single ranking"
    - "Query analyzer detects camelCase identifiers (e.g., getUserById triggers hybrid)"
    - "Query analyzer detects snake_case identifiers (e.g., get_user_by_id triggers hybrid)"
    - "Keyword search returns results matching substring in content_text"
  artifacts:
    - path: "src/cocosearch/search/hybrid.py"
      provides: "RRF fusion algorithm and hybrid search execution"
      min_lines: 80
    - path: "src/cocosearch/search/query_analyzer.py"
      provides: "Query pattern detection for auto-hybrid triggering"
      min_lines: 40
    - path: "tests/unit/test_hybrid_search.py"
      provides: "Unit tests for RRF fusion logic"
      min_lines: 60
    - path: "tests/unit/test_query_analyzer.py"
      provides: "Unit tests for query pattern detection"
      min_lines: 40
  key_links:
    - from: "src/cocosearch/search/hybrid.py"
      to: "PostgreSQL tsquery"
      via: "plainto_tsquery or to_tsquery SQL function"
      pattern: "tsquery"
    - from: "src/cocosearch/search/query_analyzer.py"
      to: "camelCase/snake_case detection"
      via: "regex pattern matching"
      pattern: "[A-Z][a-z]|_[a-z]"
---

<objective>
Implement the core hybrid search algorithm and query analyzer for Phase 28.

Purpose: Create the RRF (Reciprocal Rank Fusion) algorithm that combines vector similarity and keyword matching results, plus query analysis to auto-detect when hybrid search should be triggered.

Output:
- hybrid.py: RRF fusion algorithm, keyword search execution via tsquery
- query_analyzer.py: Pattern detection for camelCase/snake_case identifiers
- Unit tests for both modules
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-hybrid-search-query/28-CONTEXT.md
@.planning/phases/27-hybrid-search-foundation/27-03-SUMMARY.md

Key existing code:
@src/cocosearch/search/query.py (existing vector search implementation)
@src/cocosearch/indexer/tsvector.py (preprocessing logic for identifiers)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create query analyzer module</name>
  <files>src/cocosearch/search/query_analyzer.py</files>
  <action>
Create a query analyzer module that detects identifier patterns in search queries.

The module should provide:

1. `has_identifier_pattern(query: str) -> bool`:
   - Return True if query contains camelCase pattern (e.g., "getUserById", "myFunction")
   - Return True if query contains snake_case pattern (e.g., "get_user_by_id", "my_function")
   - Return False for plain English queries (e.g., "authentication handler", "database connection")

2. `normalize_query_for_keyword(query: str) -> str`:
   - Split camelCase/snake_case identifiers into tokens (reuse logic from tsvector.py)
   - Handle both patterns: getUserById -> get user by id
   - Preserve original term AND add split tokens (for exact and partial matching)

Detection heuristics:
- camelCase: lowercase letter followed by uppercase letter (e.g., "tH" in "getHttp")
- snake_case: letters separated by underscore (e.g., "get_user")
- PascalCase: uppercase letter followed by lowercase in multi-word (e.g., "GetUser" -> 2+ parts)

Edge cases:
- Single word queries like "user" should NOT trigger auto-hybrid
- Acronyms like "HTTP" or "API" alone should NOT trigger auto-hybrid
- Mixed queries like "find getUserById function" SHOULD trigger auto-hybrid
  </action>
  <verify>
Create tests/unit/test_query_analyzer.py with tests:
- test_detects_camelcase_identifier
- test_detects_snake_case_identifier
- test_no_match_for_plain_english
- test_normalize_splits_camelcase
- test_normalize_splits_snake_case
- test_mixed_query_with_identifier

Run: `uv run pytest tests/unit/test_query_analyzer.py -v`
  </verify>
  <done>
Query analyzer correctly identifies camelCase and snake_case patterns, all unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create hybrid search module with RRF fusion</name>
  <files>src/cocosearch/search/hybrid.py, tests/unit/test_hybrid_search.py</files>
  <action>
Create the hybrid search module implementing RRF fusion.

The module should provide:

1. `execute_keyword_search(query: str, table_name: str, limit: int) -> list[KeywordResult]`:
   - Build tsquery from normalized query using plainto_tsquery('simple', ...)
   - Execute against content_tsv column with GIN index
   - Return list of (filename, start_byte, end_byte, ts_rank score) tuples
   - Handle empty results gracefully

2. `rrf_fusion(vector_results: list, keyword_results: list, k: int = 60) -> list[FusedResult]`:
   - Implement Reciprocal Rank Fusion algorithm
   - RRF score = sum(1 / (k + rank)) for each result across both lists
   - k=60 is standard RRF constant (Claude's discretion per CONTEXT.md)
   - Results appearing in both lists get higher combined score (natural RRF behavior)
   - Return results sorted by combined RRF score descending

3. `hybrid_search(query: str, index_name: str, limit: int, ...) -> list[HybridSearchResult]`:
   - Execute vector search (existing query.py logic)
   - Execute keyword search (new tsquery logic)
   - Apply RRF fusion to combine
   - Include match_type indicator: "semantic", "keyword", or "both"
   - Include score breakdown: vector_score, keyword_score, combined_score

Data structures:
```python
@dataclass
class HybridSearchResult:
    filename: str
    start_byte: int
    end_byte: int
    combined_score: float  # RRF score
    match_type: str  # "semantic", "keyword", or "both"
    vector_score: float | None  # Original cosine similarity
    keyword_score: float | None  # ts_rank score
    # ... existing metadata fields
```

Implementation notes:
- Favor keyword matches on tie-break per CONTEXT.md decision
- Double-match boost happens naturally via RRF (both ranks contribute)
- Silent fallback: if keyword returns 0, return vector-only results (no warning)
- Use 'simple' text search config (no stemming, per 27-03 decision)
  </action>
  <verify>
Create tests/unit/test_hybrid_search.py with tests:
- test_rrf_fusion_single_source (only vector or only keyword)
- test_rrf_fusion_combined_results (both sources)
- test_rrf_double_match_ranks_higher
- test_keyword_search_uses_plainto_tsquery
- test_match_type_semantic_only
- test_match_type_keyword_only
- test_match_type_both

Run: `uv run pytest tests/unit/test_hybrid_search.py -v`
  </verify>
  <done>
RRF fusion correctly combines vector and keyword results, match_type indicator works, all unit tests pass.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. Run all unit tests: `uv run pytest tests/unit/test_query_analyzer.py tests/unit/test_hybrid_search.py -v`
2. Verify no regressions in existing search tests: `uv run pytest tests/unit/test_search_query.py -v`
3. Check imports work: `uv run python -c "from cocosearch.search.hybrid import hybrid_search; from cocosearch.search.query_analyzer import has_identifier_pattern"`
</verification>

<success_criteria>
- Query analyzer correctly detects camelCase and snake_case patterns
- RRF fusion produces correct combined rankings
- Match type indicators correctly reflect result sources
- All unit tests pass
- No regressions in existing search functionality
</success_criteria>

<output>
After completion, create `.planning/phases/28-hybrid-search-query/28-01-SUMMARY.md`
</output>
