---
phase: 15-configuration-system
plan: 03
type: execute
wave: 3
depends_on: ["15-01", "15-02"]
files_modified:
  - src/cocosearch/config/generator.py
  - src/cocosearch/cli.py
  - src/cocosearch/config/__init__.py
  - tests/unit/config/test_generator.py
  - tests/unit/test_cli_init.py
autonomous: true

must_haves:
  truths:
    - "User can run 'cocosearch init' to create cocosearch.yaml"
    - "Init fails if cocosearch.yaml already exists"
    - "Generated config has all fields as comments with defaults shown"
    - "CLI loads config automatically when cocosearch.yaml exists"
    - "CLI prints 'No cocosearch.yaml found, using defaults' when no config"
  artifacts:
    - path: "src/cocosearch/config/generator.py"
      provides: "Config template generation"
      exports: ["generate_config", "CONFIG_TEMPLATE"]
    - path: "src/cocosearch/cli.py"
      provides: "Init command and config integration"
      contains: "def init_command"
    - path: "tests/unit/config/test_generator.py"
      provides: "Generator tests"
      min_lines: 30
    - path: "tests/unit/test_cli_init.py"
      provides: "CLI init command tests"
      min_lines: 30
  key_links:
    - from: "src/cocosearch/cli.py"
      to: "config.generator"
      via: "init command"
      pattern: "from cocosearch.config.generator import"
    - from: "src/cocosearch/cli.py"
      to: "config.loader"
      via: "config loading"
      pattern: "from cocosearch.config import load_config"
---

<objective>
Add CLI init command and integrate config loading into existing CLI commands.

Purpose: Enable users to generate starter config and have CLI automatically use config files.
Output: Working `cocosearch init` command and config-aware CLI commands.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-configuration-system/15-RESEARCH.md
@.planning/phases/15-configuration-system/15-CONTEXT.md
@.planning/phases/15-configuration-system/15-01-SUMMARY.md
@.planning/phases/15-configuration-system/15-02-SUMMARY.md
@src/cocosearch/cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config generator module</name>
  <files>
    src/cocosearch/config/generator.py
    src/cocosearch/config/__init__.py
  </files>
  <action>
Create generator.py with:

1. **CONFIG_TEMPLATE** constant string:
```python
CONFIG_TEMPLATE = '''\
# CocoSearch Configuration
# https://github.com/VioletCranberry/cocosearch

# Index name (optional - defaults to directory name)
# indexName: my-project

indexing:
  # File patterns to include (glob patterns)
  # includePatterns:
  #   - "*.py"
  #   - "*.js"
  #   - "*.ts"

  # File patterns to exclude (glob patterns)
  # excludePatterns:
  #   - "*_test.py"
  #   - "*.min.js"

  # Languages to index (empty = all supported languages)
  # languages:
  #   - python
  #   - typescript

  # Chunk settings
  # chunkSize: 1000
  # chunkOverlap: 300

search:
  # Maximum results returned
  # resultLimit: 10

  # Minimum similarity score (0.0 - 1.0)
  # minScore: 0.3

embedding:
  # Ollama model for embeddings
  # model: nomic-embed-text
'''
```

2. **generate_config(path: Path) -> None**:
   - Raise ConfigError if path already exists
   - Write CONFIG_TEMPLATE to path
   - No return value

3. Update __init__.py to export: `generate_config`, `CONFIG_TEMPLATE`
  </action>
  <verify>
python -c "
from cocosearch.config import generate_config, ConfigError
from pathlib import Path
import tempfile, os

# Test generation
with tempfile.TemporaryDirectory() as d:
    p = Path(d) / 'cocosearch.yaml'
    generate_config(p)
    print('Generated:', p.exists())
    print(p.read_text()[:100])
"
  </verify>
  <done>
Generator creates valid YAML template with all fields as comments
  </done>
</task>

<task type="auto">
  <name>Task 2: Add init command to CLI</name>
  <files>
    src/cocosearch/cli.py
  </files>
  <action>
Update cli.py to add init command:

1. Import at top:
   ```python
   from cocosearch.config import generate_config, ConfigError as ConfigLoadError
   ```
   (Use alias to avoid conflict with any existing ConfigError)

2. Add **init_command(args: argparse.Namespace) -> int**:
   - Get config_path = Path.cwd() / "cocosearch.yaml"
   - Try generate_config(config_path)
   - On success: print "[green]Created cocosearch.yaml[/green]" and "[dim]Edit this file to customize CocoSearch behavior.[/dim]"
   - On ConfigLoadError: print error in red, return 1
   - Return 0 on success

3. Add init subparser in main():
   ```python
   init_parser = subparsers.add_parser(
       "init",
       help="Create a cocosearch.yaml configuration file",
       description="Generate a starter configuration file with all options documented.",
   )
   ```

4. Add "init" to known_subcommands tuple

5. Add handler in command dispatch:
   ```python
   elif args.command == "init":
       sys.exit(init_command(args))
   ```
  </action>
  <verify>
cd /tmp && rm -f cocosearch.yaml && python -m cocosearch init && cat cocosearch.yaml | head -5
  </verify>
  <done>
`cocosearch init` creates cocosearch.yaml in current directory
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate config loading into CLI commands</name>
  <files>
    src/cocosearch/cli.py
  </files>
  <action>
Update cli.py to load config automatically:

1. Import additional items:
   ```python
   from cocosearch.config import load_config, find_config_file, CocoSearchConfig
   ```

2. Update **index_command**:
   - Replace the current config loading logic with:
     ```python
     # Load config from cocosearch.yaml if present
     config_path = find_config_file()
     if config_path:
         console.print(f"[dim]Loading config from {config_path}[/dim]")
         try:
             project_config = load_config(config_path)
         except ConfigLoadError as e:
             console.print(f"[bold red]Configuration error:[/bold red]\n{e}")
             return 1
     else:
         console.print("[dim]No cocosearch.yaml found, using defaults[/dim]")
         project_config = CocoSearchConfig()
     ```
   - Create IndexingConfig from project_config fields:
     ```python
     # Map project config to IndexingConfig
     from cocosearch.indexer import IndexingConfig as LegacyIndexingConfig
     config = LegacyIndexingConfig(
         include_patterns=project_config.indexing.includePatterns or LegacyIndexingConfig().include_patterns,
         exclude_patterns=project_config.indexing.excludePatterns,
         chunk_size=project_config.indexing.chunkSize,
         chunk_overlap=project_config.indexing.chunkOverlap,
     )
     ```
   - Use project_config.indexName if set (override derived name)
   - Keep CLI arg overrides (--include, --exclude) as they currently work

3. Update **search_command**:
   - After determining index_name, load config for search defaults:
     ```python
     # Load config for search settings
     config_path = find_config_file()
     if config_path:
         try:
             project_config = load_config(config_path)
         except ConfigLoadError:
             project_config = CocoSearchConfig()
     else:
         project_config = CocoSearchConfig()
     ```
   - Use project_config.search.resultLimit as default for limit if not specified via CLI
   - Use project_config.search.minScore as default for min_score if not specified via CLI
   - Keep CLI args taking precedence (this is Phase 16 territory, but we prepare the foundation)

Note: The full CLI flag precedence implementation is Phase 16 (CONF-09). This plan just integrates config loading with the "first run" message and basic defaults.
  </action>
  <verify>
cd /tmp && rm -f cocosearch.yaml && python -m cocosearch index . 2>&1 | head -3
# Should show "No cocosearch.yaml found, using defaults"
  </verify>
  <done>
CLI commands load config when present, show message when no config found
  </done>
</task>

<task type="auto">
  <name>Task 4: Unit tests for generator and CLI init</name>
  <files>
    tests/unit/config/test_generator.py
    tests/unit/test_cli_init.py
  </files>
  <action>
Create test_generator.py:

1. **test_generate_config_creates_file**:
   - Generate to tmp path
   - Assert file exists
   - Assert content matches CONFIG_TEMPLATE

2. **test_generate_config_fails_if_exists**:
   - Create file first
   - Assert generate_config raises ConfigError

3. **test_config_template_is_valid_yaml**:
   - Parse CONFIG_TEMPLATE with yaml.safe_load
   - Assert it parses without error (empty sections are valid)

Create test_cli_init.py:

1. **test_init_command_creates_config**:
   - Change to tmp directory
   - Run init_command with mock args
   - Assert cocosearch.yaml created

2. **test_init_command_fails_if_exists**:
   - Create cocosearch.yaml first
   - Run init_command
   - Assert returns 1

3. **test_init_command_output**:
   - Capture console output
   - Assert "Created cocosearch.yaml" in output

Use pytest fixtures, tmp_path, and monkeypatch for cwd changes.
  </action>
  <verify>
pytest tests/unit/config/test_generator.py tests/unit/test_cli_init.py -v
  </verify>
  <done>
All generator and CLI init tests pass
  </done>
</task>

</tasks>

<verification>
1. `cocosearch init` creates config file in current directory
2. `cocosearch init` fails with error if config already exists
3. `cocosearch index .` prints "No cocosearch.yaml found, using defaults" when no config
4. `cocosearch index .` prints "Loading config from..." when config exists
5. `pytest tests/unit/config/test_generator.py tests/unit/test_cli_init.py -v` passes
</verification>

<success_criteria>
- Init command creates valid cocosearch.yaml template
- Init command fails gracefully if file exists
- CLI commands detect and load config automatically
- "No config found" message appears on first run (CONF-08 user feedback)
- Config validation errors prevent command execution with helpful message
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-configuration-system/15-03-SUMMARY.md`
</output>
