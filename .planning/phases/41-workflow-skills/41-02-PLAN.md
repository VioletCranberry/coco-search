---
phase: 41-workflow-skills
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/coco-debugging/SKILL.md
autonomous: true

must_haves:
  truths:
    - "Debugging skill guides users through finding root cause of issues"
    - "Skill entry point accepts error message, stack trace, or unexpected behavior description"
    - "Skill casts wide net first: semantic search for symptom AND symbol search for identifiers"
    - "Trace depth is adaptive: one hop first, then offer to trace deeper"
    - "Skill defaults to locating root cause, then asks if user wants fix suggestions"
    - "Skill auto-executes CocoSearch searches at each step without manual triggering"
    - "Skill uses adaptive branching based on findings (not rigid linear)"
  artifacts:
    - path: "skills/coco-debugging/SKILL.md"
      provides: "Debugging workflow skill for Claude Code"
      min_lines: 100
      contains: "search_code"
  key_links:
    - from: "skills/coco-debugging/SKILL.md"
      to: "CocoSearch MCP tools"
      via: "search_code, list_indexes, index_stats tool references"
      pattern: "search_code|list_indexes|index_stats"
---

<objective>
Create the debugging workflow skill that guides users through finding the root cause of issues using CocoSearch.

Purpose: Give users a systematic debugging experience -- wide-net search for symptoms, adaptive tracing through call chains, root cause identification -- all powered by semantic and symbol search.
Output: SKILL.md file in skills/coco-debugging/ directory
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/41-workflow-skills/41-CONTEXT.md
@.planning/phases/41-workflow-skills/41-RESEARCH.md
@.claude/skills/cocosearch/SKILL.md (existing skill for format reference)
@src/cocosearch/mcp/server.py (MCP tool signatures)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create debugging workflow skill</name>
  <files>skills/coco-debugging/SKILL.md</files>
  <action>
Create `skills/coco-debugging/SKILL.md` with the following structure:

**Frontmatter:**
```yaml
---
name: coco-debugging
description: "Use when debugging an error, unexpected behavior, or tracing how code flows through a system. Guides root cause analysis using CocoSearch semantic and symbol search."
---
```

**Content -- adaptive branching workflow:**

The skill should read like a senior developer helping debug a problem. Conversational, systematic, not documentation-style.

**Structure:**

1. **Pre-flight Check** (~10 lines)
   - Use `list_indexes()` and `index_stats()` to verify index exists and is reasonably fresh
   - If stale (>7 days), warn that results may not reflect recent code changes
   - If no index, offer to run `index_codebase(path)` first

2. **Step 1: Understand the Symptom** (~10 lines)
   - Parse user's input: Is it an error message? Stack trace? Description of unexpected behavior?
   - Extract key identifiers: function names, class names, error types, variable names
   - Extract semantic context: what the user expects vs what's happening

3. **Step 2: Cast Wide Net** (~30 lines)
   - This is the critical first search step. Run BOTH searches simultaneously:
     - **Semantic search:** `search_code(query="<user's symptom description>", use_hybrid_search=True, smart_context=True)`
     - **Symbol search:** For each identifier extracted from the symptom:
       - `search_code(query="<identifier>", symbol_name="<identifier>*", use_hybrid_search=True)`
   - Synthesize results: Which files/functions appear in both searches? These are the strongest leads.
   - Present findings: "Based on the symptom, the issue likely originates in X, which is called by Y."
   - Branch based on what was found:
     - If clear error origin found -> proceed to trace
     - If multiple candidates -> ask user which area to focus on
     - If nothing relevant found -> try broader search terms, different identifier patterns

4. **Step 3: Trace the Call Chain (Adaptive Depth)** (~25 lines)
   - Start with ONE HOP: find immediate callers and callees of the suspected origin
     - `search_code(query="calls <function_name>", use_hybrid_search=True, symbol_type="function")`
     - `search_code(query="<function_name>", symbol_name="<function_name>", smart_context=True)` for the function itself
   - Present the one-hop view: "Function X is called by A, B, C. It calls D, E."
   - Ask: "Want me to trace deeper?" (user checkpoint before expanding)
   - If yes, trace the next hop for the most suspicious caller/callee
   - Continue until root cause is identified or user says stop

5. **Step 4: Root Cause Analysis** (~15 lines)
   - Present the root cause: what's wrong, where it is, why it causes the symptom
   - Show the relevant code with `smart_context=True` for full function bodies
   - Ask: "Want me to suggest a fix?" (do NOT auto-suggest fixes)
   - If user wants a fix:
     - Search for similar patterns in the codebase: `search_code("how <similar_thing> is handled correctly")`
     - Suggest fix based on established patterns in the codebase

**Key design decisions:**
- Combine semantic search + symbol filtering in the SAME step for richer context (per user spec)
- Use `use_hybrid_search=True` heavily -- debugging involves specific identifiers
- Use `symbol_name` with glob patterns to find related functions (e.g., "handle*Error")
- Use `smart_context=True` to see full function bodies, not just matching lines
- Default to locating root cause ONLY -- fix suggestions are opt-in
- Trace depth is user-controlled: start shallow, go deeper on request

**Installation section at bottom** (~10 lines):
- Claude Code: `cp skills/coco-debugging/SKILL.md ~/.claude/skills/coco-debugging/SKILL.md`
- OpenCode: `cp skills/coco-debugging/SKILL.md ~/.config/opencode/skills/coco-debugging/SKILL.md`
  </action>
  <verify>
File exists: `ls -la skills/coco-debugging/SKILL.md`
Line count: `wc -l skills/coco-debugging/SKILL.md` (should be 100-180 lines)
Contains MCP tool references: `grep -c "search_code\|list_indexes\|index_stats" skills/coco-debugging/SKILL.md` (should be >= 4)
Contains adaptive tracing: `grep -ci "trace\|hop\|deeper\|callers\|callees" skills/coco-debugging/SKILL.md` (should be >= 3)
Contains root cause: `grep -ci "root cause" skills/coco-debugging/SKILL.md` (should be >= 1)
Has valid frontmatter: `head -5 skills/coco-debugging/SKILL.md` shows YAML block
  </verify>
  <done>
Debugging workflow skill exists at skills/coco-debugging/SKILL.md with:
- Valid YAML frontmatter with "Use when..." description
- Pre-flight index check
- Wide-net initial search combining semantic + symbol search
- Adaptive trace depth (one hop, then ask to go deeper)
- Root cause analysis presentation
- Opt-in fix suggestions (not forced)
- Installation instructions for both platforms
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate debugging skill completeness</name>
  <files>skills/coco-debugging/SKILL.md</files>
  <action>
Validate the created SKILL.md meets all phase requirements:

1. **Frontmatter validation:**
   - Has valid YAML frontmatter with `name` and `description`
   - Description starts with "Use when..." (triggering condition)
   - Total frontmatter under 1024 characters

2. **Entry point validation:**
   - Skill accepts: error messages, stack traces, unexpected behavior descriptions
   - Extracts identifiers from user input for targeted search

3. **Wide net validation:**
   - First search step uses BOTH semantic search AND symbol search
   - Uses `use_hybrid_search=True` for identifier-heavy searching
   - Synthesizes results from multiple searches before presenting

4. **Adaptive trace validation:**
   - Starts with one hop (not deep trace immediately)
   - Presents findings and asks user before tracing deeper
   - Does NOT force-expand to full call graph

5. **Root cause validation:**
   - Defaults to presenting root cause only
   - Fix suggestions are opt-in ("Want me to suggest a fix?")
   - Does NOT auto-generate fixes

6. **Installation instructions present for both platforms**

If any validation fails, update the file to fix issues.
  </action>
  <verify>
Description trigger: `sed -n '/^description:/p' skills/coco-debugging/SKILL.md` starts with "Use when"
Wide net: `grep -c "hybrid\|symbol_name\|symbol_type" skills/coco-debugging/SKILL.md` >= 3
Adaptive depth: `grep -ci "want me to\|deeper\|ask\|shall I" skills/coco-debugging/SKILL.md` >= 2
Fix opt-in: `grep -ci "suggest a fix\|want.*fix" skills/coco-debugging/SKILL.md` >= 1
  </verify>
  <done>
Debugging skill passes all validation:
- Valid frontmatter with "Use when..." description
- Accepts error messages, stack traces, and behavior descriptions
- Wide-net first search with semantic + symbol combination
- Adaptive trace depth with user checkpoints
- Root cause analysis with opt-in fix suggestions
- Installation instructions for both platforms
  </done>
</task>

</tasks>

<verification>
1. File exists: `ls skills/coco-debugging/SKILL.md`
2. Frontmatter valid: `head -5 skills/coco-debugging/SKILL.md` shows YAML block
3. MCP tools referenced: `grep -c "search_code\|list_indexes\|index_stats" skills/coco-debugging/SKILL.md` >= 4
4. Wide net search: `grep -ci "semantic.*symbol\|symbol.*semantic\|both\|simultaneously" skills/coco-debugging/SKILL.md` >= 1
5. Adaptive depth: `grep -ci "one hop\|trace deeper\|want me" skills/coco-debugging/SKILL.md` >= 2
6. Root cause: `grep -ci "root cause" skills/coco-debugging/SKILL.md` >= 1
7. Installation: `grep -c "claude/skills\|opencode" skills/coco-debugging/SKILL.md` >= 2
</verification>

<success_criteria>
- Debugging workflow skill exists at skills/coco-debugging/SKILL.md
- Skill loads without YAML errors (valid frontmatter with "Use when..." description)
- Skill accepts error messages, stack traces, or unexpected behavior descriptions
- Skill casts wide net first with combined semantic + symbol search
- Skill traces call chains with adaptive depth (one hop, then ask)
- Skill presents root cause analysis without forcing fix suggestions
- Fix suggestions are opt-in only
- Skill auto-executes CocoSearch searches (not manual CLI commands)
- Skill uses adaptive branching (not rigid linear steps)
</success_criteria>

<output>
After completion, create `.planning/phases/41-workflow-skills/41-02-SUMMARY.md`
</output>
