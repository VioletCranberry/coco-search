---
phase: 41-workflow-skills
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/coco-refactoring/SKILL.md
autonomous: true

must_haves:
  truths:
    - "Refactoring skill guides users through safe code changes with impact analysis"
    - "Skill entry point accepts refactoring goal description"
    - "Impact analysis produces full dependency map: all usages, test coverage, downstream effects"
    - "Skill produces a step-by-step refactoring plan with ordered safe changes"
    - "Skill can execute each refactoring step with user confirmation before each change"
    - "Skill auto-executes CocoSearch searches at each step without manual triggering"
    - "Skill uses adaptive branching based on findings (not rigid linear)"
  artifacts:
    - path: "skills/coco-refactoring/SKILL.md"
      provides: "Refactoring workflow skill for Claude Code"
      min_lines: 100
      contains: "search_code"
  key_links:
    - from: "skills/coco-refactoring/SKILL.md"
      to: "CocoSearch MCP tools"
      via: "search_code, list_indexes, index_stats tool references"
      pattern: "search_code|list_indexes|index_stats"
---

<objective>
Create the refactoring workflow skill that guides users through safe code changes with full impact analysis using CocoSearch.

Purpose: Give users confidence when refactoring -- full dependency mapping, test coverage check, ordered refactoring plan, and step-by-step execution with confirmation gates.
Output: SKILL.md file in skills/coco-refactoring/ directory
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/41-workflow-skills/41-CONTEXT.md
@.planning/phases/41-workflow-skills/41-RESEARCH.md
@.claude/skills/cocosearch/SKILL.md (existing skill for format reference)
@src/cocosearch/mcp/server.py (MCP tool signatures)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create refactoring workflow skill</name>
  <files>skills/coco-refactoring/SKILL.md</files>
  <action>
Create `skills/coco-refactoring/SKILL.md` with the following structure:

**Frontmatter:**
```yaml
---
name: coco-refactoring
description: "Use when planning a refactoring, extracting code into a new module, renaming across the codebase, or splitting a large file. Guides impact analysis and safe step-by-step execution using CocoSearch."
---
```

**Content -- adaptive branching workflow:**

The skill should read like a senior developer guiding safe refactoring. Systematic but adaptive. User stays in control of every change.

**Structure:**

1. **Pre-flight Check** (~10 lines)
   - Use `list_indexes()` and `index_stats()` to verify index exists and is fresh
   - Refactoring on stale index is risky -- strongly recommend reindexing if >7 days old
   - If no index, require indexing before proceeding (unlike onboarding/debugging, refactoring NEEDS accurate data)

2. **Step 1: Understand the Refactoring Goal** (~10 lines)
   - Parse user's description: What kind of refactoring?
     - Extract into new module/service
     - Rename symbol across codebase
     - Split large file into smaller ones
     - Move code between modules
     - Change interface/API signature
   - Identify the target: which file(s), function(s), class(es) are being refactored

3. **Step 2: Impact Analysis (Full Dependency Map)** (~35 lines)
   - This is the critical step. Build a complete picture of what will be affected:

   **a) Find all usages of the target:**
   - `search_code(query="<target_symbol>", symbol_name="<target_symbol>*", use_hybrid_search=True)`
   - `search_code(query="import <target_module>", use_hybrid_search=True)` for import references
   - `search_code(query="from <target_module> import", use_hybrid_search=True)` for Python-style imports

   **b) Find test coverage:**
   - `search_code(query="test <target_symbol>", symbol_name="test_*<target>*", symbol_type="function")`
   - `search_code(query="<target_symbol>", language="python")` filtered to test directories (look for test_/tests/ in paths)

   **c) Find downstream effects:**
   - For each caller found in (a), check what THEY export/provide
   - `search_code(query="<caller_function>", symbol_name="<caller>*", use_hybrid_search=True)`

   **d) Present the dependency map:**
   - "Symbol X is used in N files: [list]"
   - "Test coverage: M test files cover this symbol: [list]"
   - "Downstream: changing X will affect Y, Z (they import/call X)"
   - "Risk assessment: [low/medium/high] based on usage count and test coverage"

   **Branch based on impact:**
   - Low impact (1-3 usages, good test coverage) -> proceed to plan
   - Medium impact (4-10 usages) -> present map, ask user to confirm scope
   - High impact (10+ usages or no test coverage) -> warn, suggest incremental approach

4. **Step 3: Generate Refactoring Plan** (~20 lines)
   - Produce an ordered list of changes to make safely:
     - Order: leaf dependencies first, then work up to the target
     - Each step: what file to change, what to do, why this order
   - Example plan structure:
     1. Create new module/file (if extracting)
     2. Move/copy target code to new location
     3. Update imports in dependent files (leaf-first)
     4. Update tests to reference new location
     5. Remove old code (last step)
   - Present the plan and ask: "Ready to execute, or want to adjust?"

5. **Step 4: Execute with Confirmation Gates** (~20 lines)
   - For each step in the plan:
     - Show what will change (file, lines, before/after preview)
     - Ask "Proceed with this change?" (user confirmation required)
     - Make the change
     - Run any available tests to verify no breakage
   - After all steps: suggest running full test suite
   - If any step causes test failures: stop, show failure, ask how to proceed

**Key design decisions:**
- Impact analysis is the MOST important step -- spend the most search effort here
- Use `use_hybrid_search=True` for all searches (refactoring is identifier-heavy)
- Use `symbol_name` with glob patterns to find all variants (e.g., "User*" catches User, UserProfile, UserService)
- Use `smart_context=True` to see full function/class bodies for understanding dependencies
- Every code change requires user confirmation (user stays in control)
- Suggest running tests after each change, not just at the end
- Leaf-first ordering prevents cascading import failures

**Installation section at bottom** (~10 lines):
- Claude Code: `cp skills/coco-refactoring/SKILL.md ~/.claude/skills/coco-refactoring/SKILL.md`
- OpenCode: `cp skills/coco-refactoring/SKILL.md ~/.config/opencode/skills/coco-refactoring/SKILL.md`
  </action>
  <verify>
File exists: `ls -la skills/coco-refactoring/SKILL.md`
Line count: `wc -l skills/coco-refactoring/SKILL.md` (should be 100-180 lines)
Contains MCP tool references: `grep -c "search_code\|list_indexes\|index_stats" skills/coco-refactoring/SKILL.md` (should be >= 4)
Contains impact analysis: `grep -ci "impact\|dependency\|usages\|downstream" skills/coco-refactoring/SKILL.md` (should be >= 3)
Contains execution gates: `grep -ci "confirm\|proceed\|approval\|permission" skills/coco-refactoring/SKILL.md` (should be >= 2)
Has valid frontmatter: `head -5 skills/coco-refactoring/SKILL.md` shows YAML block
  </verify>
  <done>
Refactoring workflow skill exists at skills/coco-refactoring/SKILL.md with:
- Valid YAML frontmatter with "Use when..." description
- Pre-flight index check (require fresh index for refactoring)
- Refactoring goal parsing
- Full impact analysis: all usages + test coverage + downstream effects
- Ordered refactoring plan (leaf-first for safety)
- Step-by-step execution with user confirmation before each change
- Test verification after changes
- Installation instructions for both platforms
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate refactoring skill completeness</name>
  <files>skills/coco-refactoring/SKILL.md</files>
  <action>
Validate the created SKILL.md meets all phase requirements:

1. **Frontmatter validation:**
   - Has valid YAML frontmatter with `name` and `description`
   - Description starts with "Use when..." (triggering condition)
   - Total frontmatter under 1024 characters

2. **Impact analysis validation:**
   - Searches for ALL usages of the target symbol
   - Searches for test coverage
   - Searches for downstream effects (callers of callers)
   - Presents a dependency map with risk assessment

3. **Refactoring plan validation:**
   - Produces ordered list of changes (leaf-first)
   - Each step has: file, action, reason for order
   - Plan is presented to user before execution

4. **Execution gate validation:**
   - Each change requires user confirmation
   - User can adjust the plan before execution
   - Tests are suggested after changes
   - Failure handling: stop on test failure, ask user

5. **Installation instructions present for both platforms**

If any validation fails, update the file to fix issues.
  </action>
  <verify>
Description trigger: `sed -n '/^description:/p' skills/coco-refactoring/SKILL.md` starts with "Use when"
Impact analysis: `grep -ci "usage\|import\|downstream\|test coverage" skills/coco-refactoring/SKILL.md` >= 3
Execution gates: `grep -ci "confirm\|proceed\|ready" skills/coco-refactoring/SKILL.md` >= 2
Ordered plan: `grep -ci "order\|first\|then\|before\|after\|leaf" skills/coco-refactoring/SKILL.md` >= 2
  </verify>
  <done>
Refactoring skill passes all validation:
- Valid frontmatter with "Use when..." description
- Full impact analysis with dependency map
- Ordered refactoring plan (leaf-first)
- User confirmation before each code change
- Test verification after changes
- Installation instructions for both platforms
  </done>
</task>

</tasks>

<verification>
1. File exists: `ls skills/coco-refactoring/SKILL.md`
2. Frontmatter valid: `head -5 skills/coco-refactoring/SKILL.md` shows YAML block
3. MCP tools referenced: `grep -c "search_code\|list_indexes\|index_stats" skills/coco-refactoring/SKILL.md` >= 4
4. Impact analysis: `grep -ci "impact\|dependency\|downstream\|usage" skills/coco-refactoring/SKILL.md` >= 3
5. Execution gates: `grep -ci "confirm\|proceed\|approval" skills/coco-refactoring/SKILL.md` >= 2
6. Ordered plan: `grep -ci "order\|leaf.*first\|step.*by.*step" skills/coco-refactoring/SKILL.md` >= 1
7. Installation: `grep -c "claude/skills\|opencode" skills/coco-refactoring/SKILL.md` >= 2
</verification>

<success_criteria>
- Refactoring workflow skill exists at skills/coco-refactoring/SKILL.md
- Skill loads without YAML errors (valid frontmatter with "Use when..." description)
- Skill accepts refactoring goal descriptions (extract, rename, split, move)
- Skill produces full impact analysis (usages + test coverage + downstream effects)
- Skill generates ordered refactoring plan (leaf-first for safety)
- Skill executes step-by-step with user confirmation before each change
- Skill suggests test verification after changes
- Skill auto-executes CocoSearch searches (not manual CLI commands)
- Skill uses adaptive branching based on impact level
</success_criteria>

<output>
After completion, create `.planning/phases/41-workflow-skills/41-03-SUMMARY.md`
</output>
