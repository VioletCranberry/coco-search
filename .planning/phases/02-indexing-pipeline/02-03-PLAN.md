---
phase: 02-indexing-pipeline
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/cocosearch/indexer/progress.py
  - src/cocosearch/cli.py
  - src/cocosearch/indexer/__init__.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "User can run CLI command to index a directory"
    - "Progress bar shows indexing status"
    - "CLI derives index name from directory path by default"
    - "CLI allows explicit index name override"
    - "Summary printed at completion with file count"
  artifacts:
    - path: "src/cocosearch/cli.py"
      provides: "CLI entry point for indexing"
      exports: ["main", "index_command"]
    - path: "src/cocosearch/indexer/progress.py"
      provides: "Progress reporting utilities"
      exports: ["IndexingProgress"]
    - path: "pyproject.toml"
      provides: "CLI script entry point"
      contains: "[project.scripts]"
  key_links:
    - from: "src/cocosearch/cli.py"
      to: "src/cocosearch/indexer/flow.py"
      via: "Calls run_index"
      pattern: "run_index"
    - from: "src/cocosearch/cli.py"
      to: "rich"
      via: "Progress bar display"
      pattern: "rich\\.(progress|console)"
    - from: "pyproject.toml"
      to: "src/cocosearch/cli.py"
      via: "Script entry point"
      pattern: "cocosearch.*=.*cli"
---

<objective>
Create CLI interface with progress reporting for the indexing pipeline.

Purpose: Provide user-facing CLI commands for indexing codebases with visual progress feedback. This completes MCP-05 (progress feedback) and makes the indexing pipeline usable. The CLI will be wrapped by the MCP server in Phase 4.

Output: `cocosearch index <path>` CLI command with progress bar and completion summary.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-indexing-pipeline/02-RESEARCH.md
@.planning/phases/02-indexing-pipeline/02-CONTEXT.md
@.planning/phases/02-indexing-pipeline/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create progress reporting module</name>
  <files>src/cocosearch/indexer/progress.py</files>
  <action>
Create `progress.py` with progress reporting utilities using Rich library.

Implement:

1. `IndexingProgress` class:
   - Uses rich.progress.Progress with:
     - SpinnerColumn
     - TextColumn for description
     - BarColumn (optional, for when count known)
     - TaskProgressColumn
     - TimeElapsedColumn
   - Methods:
     - `__init__(self, console: Console | None = None)` - create progress context
     - `__enter__` / `__exit__` for context manager
     - `start_indexing(self, codebase_path: str)` - display "Indexing {path}..." message
     - `update_status(self, message: str)` - update progress description
     - `complete(self, stats: dict)` - print completion summary with file counts

2. `print_summary(stats: dict, console: Console | None = None)` standalone function:
   - Pretty-print indexing statistics
   - Show: files processed, chunks created, time elapsed
   - Use rich.console.Console for colored output

Export: IndexingProgress, print_summary

Keep it simple - CocoIndex handles the actual file processing internally, so we mainly show start/end status rather than per-file progress.
  </action>
  <verify>
Run:
```
uv run python -c "
from cocosearch.indexer.progress import IndexingProgress, print_summary
from rich.console import Console
console = Console()
print_summary({'files_added': 5, 'files_removed': 0, 'files_updated': 2}, console)
print('OK')
"
```
Should print a formatted summary and OK.
  </verify>
  <done>Progress reporting module created with Rich-based progress display and summary printing.</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI entry point</name>
  <files>src/cocosearch/cli.py, pyproject.toml</files>
  <action>
Create `cli.py` with CLI commands using argparse (simpler than click for this use case).

Implement:

1. `derive_index_name(path: str) -> str` helper:
   - Convert path to absolute
   - Extract directory name (last component)
   - Sanitize: lowercase, replace non-alphanumeric with underscore
   - Handle edge cases: root path, trailing slashes
   - Example: "/home/user/MyProject" -> "myproject"

2. `index_command(args)` function:
   - Required arg: path (directory to index)
   - Optional args:
     - --name / -n: explicit index name (overrides auto-derive)
     - --include / -i: additional include patterns (can repeat)
     - --exclude / -e: additional exclude patterns (can repeat)
     - --no-gitignore: disable .gitignore respect
   - Load config from .cocosearch.yaml if present
   - Merge CLI args with config (CLI overrides config)
   - Initialize cocoindex
   - Show progress with IndexingProgress
   - Run indexing via run_index()
   - Print summary

3. `main()` function:
   - Create ArgumentParser with subcommands
   - Add "index" subcommand
   - Parse args and dispatch

4. In pyproject.toml, add script entry point:
   ```toml
   [project.scripts]
   cocosearch = "cocosearch.cli:main"
   ```

Error handling:
- Path doesn't exist -> clear error message, exit 1
- Indexing fails -> show error, list any skipped files, exit 1
- Success -> exit 0
  </action>
  <verify>
Run:
```
# Check CLI is registered
uv run cocosearch --help

# Check index subcommand
uv run cocosearch index --help

# Test derive_index_name
uv run python -c "
from cocosearch.cli import derive_index_name
assert derive_index_name('/home/user/MyProject') == 'myproject'
assert derive_index_name('/tmp/test-repo/') == 'test_repo'
print('derive_index_name OK')
"
```
  </verify>
  <done>CLI entry point created with `cocosearch index` command, argument parsing, and progress display.</done>
</task>

<task type="auto">
  <name>Task 3: End-to-end integration test</name>
  <files>None (verification only)</files>
  <action>
Run full end-to-end test of the indexing pipeline.

Prerequisites:
- Docker Compose running (PostgreSQL)
- Ollama running with nomic-embed-text model

Steps:
1. Create a test codebase directory with sample files:
   - Python file with function and class
   - JavaScript file with function
   - A .gitignore file
   - A file that should be ignored

2. Run: `uv run cocosearch index /path/to/test --name e2e_test`

3. Verify:
   - Progress shown during indexing
   - Summary printed at end
   - Chunks exist in PostgreSQL: `SELECT COUNT(*) FROM e2e_test_chunks;`
   - Ignored files not indexed (check filenames in table)

4. Test incremental: Add a new file, re-run index, verify only new file processed

5. Clean up: Drop the test table
  </action>
  <verify>
```bash
# Setup test directory
mkdir -p /tmp/e2e_test_codebase
cat > /tmp/e2e_test_codebase/main.py << 'EOF'
def main():
    """Entry point for the application."""
    print("Hello, World!")

class App:
    def __init__(self, name: str):
        self.name = name

    def run(self):
        return f"Running {self.name}"
EOF

cat > /tmp/e2e_test_codebase/utils.js << 'EOF'
function formatDate(date) {
    return date.toISOString();
}

export { formatDate };
EOF

echo "node_modules/" > /tmp/e2e_test_codebase/.gitignore
mkdir -p /tmp/e2e_test_codebase/node_modules
echo "console.log('ignored');" > /tmp/e2e_test_codebase/node_modules/ignored.js

# Run indexing
uv run cocosearch index /tmp/e2e_test_codebase --name e2e_test

# Verify chunks in database
docker exec coco-s-db-1 psql -U cocoindex -d cocoindex -c "SELECT filename, location FROM e2e_test_chunks LIMIT 10;"

# Verify ignored file not indexed
docker exec coco-s-db-1 psql -U cocoindex -d cocoindex -c "SELECT COUNT(*) FROM e2e_test_chunks WHERE filename LIKE '%node_modules%';"
# Should return 0

# Cleanup
docker exec coco-s-db-1 psql -U cocoindex -d cocoindex -c "DROP TABLE IF EXISTS e2e_test_chunks;"
rm -rf /tmp/e2e_test_codebase
```
  </verify>
  <done>End-to-end integration test passes: CLI indexes codebase, respects .gitignore, stores chunks in PostgreSQL with embeddings.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. CLI installed and working:
   ```bash
   uv run cocosearch --help
   uv run cocosearch index --help
   ```

2. Index name derivation:
   ```bash
   uv run python -c "from cocosearch.cli import derive_index_name; print(derive_index_name('/Users/test/my-project'))"
   ```

3. Full pipeline test (requires infrastructure):
   ```bash
   # Create minimal test
   mkdir -p /tmp/cli_test && echo "def test(): pass" > /tmp/cli_test/t.py

   # Run indexing
   uv run cocosearch index /tmp/cli_test --name cli_test

   # Check result
   docker exec coco-s-db-1 psql -U cocoindex -d cocoindex -c "SELECT COUNT(*) FROM cli_test_chunks;"

   # Cleanup
   docker exec coco-s-db-1 psql -U cocoindex -d cocoindex -c "DROP TABLE IF EXISTS cli_test_chunks;"
   rm -rf /tmp/cli_test
   ```

4. Verify progress output during indexing (visual check)
</verification>

<success_criteria>
- `cocosearch index <path>` CLI command works
- Index name auto-derived from directory path
- --name flag overrides auto-derived name
- --include, --exclude, --no-gitignore flags work
- Progress displayed during indexing
- Summary printed at completion with stats
- .gitignore patterns respected (ignored files not indexed)
- End-to-end test passes with real PostgreSQL and Ollama
</success_criteria>

<output>
After completion, create `.planning/phases/02-indexing-pipeline/02-03-SUMMARY.md`
</output>
