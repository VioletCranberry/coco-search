---
phase: 33-deferred-v17-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cocosearch/search/hybrid.py
  - src/cocosearch/search/query.py
  - tests/test_hybrid_symbol_filter.py
autonomous: true

must_haves:
  truths:
    - "User can search with --hybrid --symbol-type function and get filtered results from both vector and keyword paths"
    - "Symbol filters apply before RRF fusion, not after"
    - "Language filter + hybrid search works correctly (if specified)"
  artifacts:
    - path: "src/cocosearch/search/hybrid.py"
      provides: "Vector and keyword search with WHERE clause support"
      contains: "where_clause"
    - path: "src/cocosearch/search/query.py"
      provides: "Hybrid search path with symbol filter support"
      contains: "should_use_hybrid"
    - path: "tests/test_hybrid_symbol_filter.py"
      provides: "Integration tests for hybrid+symbol combination"
      exports: ["test_hybrid_with_symbol_type_filter"]
  key_links:
    - from: "src/cocosearch/search/query.py"
      to: "src/cocosearch/search/hybrid.py"
      via: "hybrid_search function call with filter params"
      pattern: "hybrid_search.*symbol"
---

<objective>
Enable hybrid search to work with symbol filters by applying WHERE clauses to both vector and keyword searches before RRF fusion.

Purpose: Currently hybrid search falls back to vector-only when symbol filters are specified (query.py:269). This plan fixes that limitation so users can benefit from both hybrid search and symbol filtering simultaneously.

Output: Updated hybrid.py and query.py that support combined hybrid+symbol search, with integration tests verifying the behavior.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-deferred-v17-foundation/33-RESEARCH.md

Reference implementation patterns from:
@src/cocosearch/search/hybrid.py
@src/cocosearch/search/query.py
@src/cocosearch/search/filters.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend hybrid.py search functions to accept WHERE clause</name>
  <files>src/cocosearch/search/hybrid.py</files>
  <action>
Modify `execute_vector_search()` and `execute_keyword_search()` functions to accept optional WHERE clause parameters:

1. Add parameters to `execute_vector_search()`:
   - `where_clause: str = ""` - SQL condition (without "WHERE")
   - `where_params: list | None = None` - Parameters for placeholders

2. Add parameters to `execute_keyword_search()`:
   - `where_clause: str = ""` - SQL condition (without "WHERE")
   - `where_params: list | None = None` - Parameters for placeholders

3. For vector search SQL:
   - Insert WHERE clause before ORDER BY
   - Inject where_params into parameter list correctly (after embedding, before ORDER BY embedding)

4. For keyword search SQL:
   - Add WHERE clause with AND to existing tsquery condition
   - Pattern: `WHERE content_tsv @@ plainto_tsquery('simple', %s) AND {where_clause}`
   - Handle case where where_clause is empty (no AND)

5. Update `hybrid_search()` function signature:
   - Add `symbol_type: str | list[str] | None = None`
   - Add `symbol_name: str | None = None`
   - Add `language_filter: str | None = None`
   - Import and use `build_symbol_where_clause` from filters.py
   - Build combined WHERE clause (language + symbol)
   - Pass WHERE clause to both execute_vector_search and execute_keyword_search

Important: Keep the existing fallback behavior when no WHERE clause is needed. Filter application must happen BEFORE fusion (per research).
  </action>
  <verify>
Run unit tests: `pytest tests/test_hybrid*.py -v`
Check that existing hybrid search tests still pass.
  </verify>
  <done>
execute_vector_search and execute_keyword_search accept and apply WHERE clauses.
hybrid_search accepts symbol_type, symbol_name, and language_filter parameters.
Existing hybrid tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update query.py to use hybrid search with filters</name>
  <files>src/cocosearch/search/query.py</files>
  <action>
Modify the search() function to pass filters to hybrid search instead of falling back to vector-only:

1. Remove the condition that disables hybrid search when symbol filters are present:
   - Current (line ~269): `if should_use_hybrid and not language_filter and not include_symbol_columns:`
   - New: `if should_use_hybrid:`

2. Pass filter parameters to hybrid_search call:
   ```python
   hybrid_results = execute_hybrid_search(
       query,
       index_name,
       limit,
       symbol_type=symbol_type,
       symbol_name=symbol_name,
       language_filter=language_filter,
   )
   ```

3. Update the import of hybrid_search to include new parameters if needed.

4. Ensure HybridSearchResult includes symbol_type, symbol_name, symbol_signature fields when present:
   - Add these fields to HybridSearchResult dataclass in hybrid.py if not present
   - Map them through to SearchResult in the conversion loop

Critical: The TODO comment at line 268 should be removed once this is implemented.
  </action>
  <verify>
Run: `cocosearch search --hybrid --symbol-type function "process data" -i test-index`
Verify results include symbol_type field and are from both semantic and keyword matches.
  </verify>
  <done>
search() function passes filters to hybrid_search instead of falling back.
TODO comment at line 268 removed.
CLI hybrid+symbol search returns filtered results with match_type indicators.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests for hybrid+symbol combination</name>
  <files>tests/test_hybrid_symbol_filter.py</files>
  <action>
Create new test file with integration tests for the hybrid+symbol filter combination:

```python
"""Integration tests for hybrid search with symbol filters.

Tests the combination of --hybrid with --symbol-type and --symbol-name filters
to ensure filters apply before RRF fusion and results include correct metadata.
"""

import pytest
from unittest.mock import patch, MagicMock

from cocosearch.search.query import search
from cocosearch.search.hybrid import hybrid_search, execute_vector_search, execute_keyword_search


class TestHybridWithSymbolFilters:
    """Tests for hybrid search combined with symbol filtering."""

    def test_hybrid_search_accepts_symbol_type_filter(self):
        """Verify hybrid_search function accepts symbol_type parameter."""
        # This is a signature test - verifies the API exists
        import inspect
        sig = inspect.signature(hybrid_search)
        assert 'symbol_type' in sig.parameters
        assert 'symbol_name' in sig.parameters

    def test_execute_vector_search_accepts_where_clause(self):
        """Verify execute_vector_search accepts WHERE clause parameters."""
        import inspect
        sig = inspect.signature(execute_vector_search)
        assert 'where_clause' in sig.parameters
        assert 'where_params' in sig.parameters

    def test_execute_keyword_search_accepts_where_clause(self):
        """Verify execute_keyword_search accepts WHERE clause parameters."""
        import inspect
        sig = inspect.signature(execute_keyword_search)
        assert 'where_clause' in sig.parameters
        assert 'where_params' in sig.parameters

    @patch('cocosearch.search.query.get_connection_pool')
    @patch('cocosearch.search.query.check_symbol_columns_exist')
    @patch('cocosearch.search.query.check_column_exists')
    @patch('cocosearch.search.query.execute_hybrid_search')
    def test_search_uses_hybrid_with_symbol_filter(
        self, mock_hybrid, mock_col_exists, mock_sym_cols, mock_pool
    ):
        """Verify search() calls hybrid_search with symbol filters when both are requested."""
        # Setup mocks
        mock_col_exists.return_value = True  # content_text exists
        mock_sym_cols.return_value = True  # symbol columns exist
        mock_hybrid.return_value = []  # Empty results for simplicity

        # Call search with hybrid + symbol filter
        search(
            query="process data",
            index_name="test",
            use_hybrid=True,
            symbol_type="function",
        )

        # Verify hybrid_search was called with symbol_type
        mock_hybrid.assert_called_once()
        call_kwargs = mock_hybrid.call_args
        # Check that symbol_type was passed (either as kwarg or in args)
        assert 'symbol_type' in str(call_kwargs) or 'function' in str(call_kwargs)


class TestWhereClauseIntegration:
    """Tests for WHERE clause building and application."""

    def test_symbol_where_clause_combined_with_keyword_search(self):
        """Verify symbol filter WHERE clause correctly combines with tsquery."""
        from cocosearch.search.filters import build_symbol_where_clause

        where, params = build_symbol_where_clause(symbol_type="function")
        assert where == "symbol_type = %s"
        assert params == ["function"]

    def test_multiple_symbol_types_in_where_clause(self):
        """Verify multiple symbol types use IN clause."""
        from cocosearch.search.filters import build_symbol_where_clause

        where, params = build_symbol_where_clause(symbol_type=["function", "method"])
        assert "IN" in where
        assert params == ["function", "method"]
```

Add additional edge case tests as needed.
  </action>
  <verify>
Run: `pytest tests/test_hybrid_symbol_filter.py -v`
All tests should pass.
  </verify>
  <done>
test_hybrid_symbol_filter.py exists with comprehensive tests.
All tests pass verifying the hybrid+symbol combination works.
  </done>
</task>

</tasks>

<verification>
1. Run full test suite: `pytest tests/ -v --tb=short`
2. Manual verification:
   - Index a test codebase: `cocosearch index ./src test-index`
   - Search with hybrid+symbol: `cocosearch search --hybrid --symbol-type function "search" -i test-index`
   - Verify results show match_type (semantic/keyword/both) AND are filtered to functions only
3. Check that hybrid-only search still works: `cocosearch search --hybrid "search" -i test-index`
4. Check that symbol-only search still works: `cocosearch search --symbol-type function "search" -i test-index`
</verification>

<success_criteria>
1. hybrid_search() accepts symbol_type, symbol_name, and language_filter parameters
2. execute_vector_search() and execute_keyword_search() accept WHERE clause parameters
3. search() function routes hybrid+symbol requests to hybrid_search (not vector-only fallback)
4. Results from hybrid+symbol search include match_type indicator and symbol metadata
5. All existing tests pass
6. New integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/33-deferred-v17-foundation/33-01-SUMMARY.md`
</output>
