---
phase: 21-language-chunking-refactor
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - src/cocosearch/handlers/hcl.py
  - src/cocosearch/handlers/dockerfile.py
  - src/cocosearch/handlers/bash.py
autonomous: true

must_haves:
  truths:
    - "HclHandler manages .tf, .hcl, .tfvars extensions"
    - "DockerfileHandler manages Dockerfile extensionless files"
    - "BashHandler manages .sh, .bash, .zsh extensions"
    - "Each handler has SEPARATOR_SPEC from existing languages.py"
    - "Each handler has extract_metadata() from existing metadata.py"
  artifacts:
    - path: "src/cocosearch/handlers/hcl.py"
      provides: "HCL language handler"
      exports: ["HclHandler"]
      contains: "EXTENSIONS.*\\.tf"
    - path: "src/cocosearch/handlers/dockerfile.py"
      provides: "Dockerfile language handler"
      exports: ["DockerfileHandler"]
      contains: "EXTENSIONS"
    - path: "src/cocosearch/handlers/bash.py"
      provides: "Bash language handler"
      exports: ["BashHandler"]
      contains: "EXTENSIONS.*\\.sh"
  key_links:
    - from: "src/cocosearch/handlers/hcl.py"
      to: "cocosearch.handlers"
      via: "registry autodiscovery"
      pattern: "EXTENSIONS.*SEPARATOR_SPEC"
    - from: "src/cocosearch/handlers/dockerfile.py"
      to: "cocosearch.handlers"
      via: "registry autodiscovery"
      pattern: "EXTENSIONS.*SEPARATOR_SPEC"
    - from: "src/cocosearch/handlers/bash.py"
      to: "cocosearch.handlers"
      via: "registry autodiscovery"
      pattern: "EXTENSIONS.*SEPARATOR_SPEC"
---

<objective>
Migrate existing language definitions and metadata extraction into self-contained handler modules.

Purpose: Each language becomes a single module with all its logic (separator spec + metadata extraction).
Output: Three handler modules (hcl.py, dockerfile.py, bash.py) that self-register via the registry.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/21-language-chunking-refactor/21-CONTEXT.md
@.planning/phases/21-language-chunking-refactor/21-RESEARCH.md
@.planning/phases/21-language-chunking-refactor/21-01-SUMMARY.md

# Source files to migrate from
@src/cocosearch/indexer/languages.py
@src/cocosearch/indexer/metadata.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HCL handler module</name>
  <files>src/cocosearch/handlers/hcl.py</files>
  <action>
    Create hcl.py with HclHandler class. Migrate from languages.py and metadata.py:

    1. **Class definition**:
       ```python
       class HclHandler:
           """Handler for HCL/Terraform files."""

           EXTENSIONS = ['.tf', '.hcl', '.tfvars']
       ```

    2. **SEPARATOR_SPEC** - Copy HCL_LANGUAGE from languages.py:
       - language_name="hcl"
       - separators_regex with 12 HCL keywords at Level 1
       - aliases=["tf", "tfvars"]

    3. **extract_metadata()** - Migrate from metadata.py:
       - Copy _HCL_COMMENT_LINE and _HCL_BLOCK_RE patterns
       - Copy _strip_leading_comments helper (make it instance method or module-level)
       - Implement extract_metadata(text: str) -> dict returning:
         - block_type: str (resource, data, variable, etc.)
         - hierarchy: str (e.g., "resource.aws_s3_bucket.data")
         - language_id: "hcl"

    4. **Keep behavior identical** to existing metadata.py:extract_hcl_metadata()
  </action>
  <verify>
    ```bash
    python -c "
    from cocosearch.handlers.hcl import HclHandler
    h = HclHandler()
    assert h.EXTENSIONS == ['.tf', '.hcl', '.tfvars']
    assert h.SEPARATOR_SPEC is not None
    m = h.extract_metadata('resource \"aws_s3_bucket\" \"data\" {')
    assert m['block_type'] == 'resource'
    assert m['hierarchy'] == 'resource.aws_s3_bucket.data'
    print('HCL handler OK')
    "
    ```
  </verify>
  <done>
    HclHandler is self-contained with SEPARATOR_SPEC and extract_metadata().
    Behavior matches existing languages.py + metadata.py.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Dockerfile and Bash handler modules</name>
  <files>src/cocosearch/handlers/dockerfile.py, src/cocosearch/handlers/bash.py</files>
  <action>
    **dockerfile.py** - Create DockerfileHandler:

    1. EXTENSIONS = ['.dockerfile']
       NOTE: Dockerfile files are extensionless. The extension mapping happens in flow.py
       via extract_language(). Use a marker extension that extract_language will return.
       Actually, check current behavior: if extract_language returns "dockerfile" for
       extensionless Dockerfile, then EXTENSIONS should contain what the registry will
       look up. Check embedder.py extract_language to understand the mapping.

       Based on metadata.py _LANGUAGE_DISPATCH, the language key is "dockerfile" not an
       extension. The registry maps extensions, so we need to handle this specially.

       DECISION: Use EXTENSIONS = [] for Dockerfile since it's extensionless. The registry
       can provide a get_handler_by_language() function for language-based lookup, or flow.py
       can special-case Dockerfile. For now, use EXTENSIONS = [] and document that Dockerfile
       is looked up by language name, not extension.

       Actually, looking at flow.py line 63: file["extension"] = file["filename"].transform(extract_language)
       This returns the LANGUAGE, not extension. So the registry lookup should be by language.

       REVISED: EXTENSIONS should match what extract_language() returns:
       - For *.tf files, extract_language returns "tf"
       - For Dockerfile, extract_language returns "dockerfile"

       So HCL should have EXTENSIONS = ['tf', 'hcl', 'tfvars'] (without dots) matching
       extract_language() output, not os.path.splitext output.

       Need to check extract_language in embedder.py to confirm.

    Let me re-read the RESEARCH.md Open Question #3: "Store WITH dot ['.tf'] to match splitext() format"
    But current code uses extract_language which returns language names without dots.

    FINAL DECISION: Keep EXTENSIONS WITHOUT dots to match extract_language() return values.
    - HCL: ['tf', 'hcl', 'tfvars']
    - Dockerfile: ['dockerfile']
    - Bash: ['sh', 'bash', 'zsh', 'shell']

    2. SEPARATOR_SPEC - Copy DOCKERFILE_LANGUAGE from languages.py

    3. extract_metadata() - Migrate from metadata.py:
       - Copy _DOCKERFILE_COMMENT_LINE, _DOCKERFILE_INSTRUCTION_RE, _DOCKERFILE_FROM_RE
       - Implement extract_metadata returning block_type, hierarchy, language_id="dockerfile"

    **bash.py** - Create BashHandler:

    1. EXTENSIONS = ['sh', 'bash', 'zsh', 'shell'] (matching language aliases)

    2. SEPARATOR_SPEC - Copy BASH_LANGUAGE from languages.py

    3. extract_metadata() - Migrate from metadata.py:
       - Copy _BASH_COMMENT_LINE, _BASH_FUNCTION_RE
       - Implement extract_metadata returning block_type, hierarchy, language_id="bash"
  </action>
  <verify>
    ```bash
    python -c "
    from cocosearch.handlers.dockerfile import DockerfileHandler
    h = DockerfileHandler()
    assert 'dockerfile' in h.EXTENSIONS
    m = h.extract_metadata('FROM golang:1.21 AS builder')
    assert m['block_type'] == 'FROM'
    assert m['hierarchy'] == 'stage:builder'
    print('Dockerfile handler OK')
    "

    python -c "
    from cocosearch.handlers.bash import BashHandler
    h = BashHandler()
    assert 'sh' in h.EXTENSIONS
    m = h.extract_metadata('function deploy_app {')
    assert m['block_type'] == 'function'
    assert m['hierarchy'] == 'function:deploy_app'
    print('Bash handler OK')
    "
    ```
  </verify>
  <done>
    DockerfileHandler and BashHandler are self-contained.
    Both auto-register via the registry when handlers package is imported.
  </done>
</task>

</tasks>

<verification>
Run from project root:

```bash
# Verify all handlers register
python -c "
from cocosearch.handlers import get_handler, get_custom_languages

# Check HCL
h = get_handler('tf')
print(f'tf -> {h.__class__.__name__}')
assert h.__class__.__name__ == 'HclHandler'

# Check Dockerfile
h = get_handler('dockerfile')
print(f'dockerfile -> {h.__class__.__name__}')
assert h.__class__.__name__ == 'DockerfileHandler'

# Check Bash
h = get_handler('sh')
print(f'sh -> {h.__class__.__name__}')
assert h.__class__.__name__ == 'BashHandler'

# Check custom languages list
langs = get_custom_languages()
print(f'Custom languages: {[l.language_name for l in langs]}')
assert len(langs) == 3

print('All handlers registered and working!')
"
```
</verification>

<success_criteria>
1. hcl.py exists with HclHandler matching existing behavior
2. dockerfile.py exists with DockerfileHandler matching existing behavior
3. bash.py exists with BashHandler matching existing behavior
4. All three handlers auto-register via package import
5. get_handler() returns correct handler for each language
6. get_custom_languages() returns all 3 CustomLanguageSpecs
</success_criteria>

<output>
After completion, create `.planning/phases/21-language-chunking-refactor/21-02-SUMMARY.md`
</output>
