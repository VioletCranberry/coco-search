---
phase: 21-language-chunking-refactor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cocosearch/handlers/__init__.py
  - src/cocosearch/handlers/_template.py
  - src/cocosearch/handlers/text.py
autonomous: true

must_haves:
  truths:
    - "handlers/__init__.py defines LanguageHandler protocol"
    - "handlers/__init__.py exports get_handler() function"
    - "TextHandler provides fallback chunking for unrecognized extensions"
  artifacts:
    - path: "src/cocosearch/handlers/__init__.py"
      provides: "Protocol, ChunkConfig, registry, get_handler"
      exports: ["LanguageHandler", "ChunkConfig", "Chunk", "get_handler"]
    - path: "src/cocosearch/handlers/_template.py"
      provides: "Template for new language handlers"
      contains: "class TemplateHandler"
    - path: "src/cocosearch/handlers/text.py"
      provides: "Default text handler for fallback"
      exports: ["TextHandler"]
  key_links:
    - from: "src/cocosearch/handlers/__init__.py"
      to: "src/cocosearch/handlers/*.py"
      via: "pathlib.glob autodiscovery"
      pattern: "glob.*\\.py"
---

<objective>
Create the handlers package foundation with Protocol interface, registry discovery, and default text handler.

Purpose: Establish the extensible plugin architecture before migrating existing language handlers.
Output: Working handlers package with Protocol definition, autodiscovery mechanism, and text fallback.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-language-chunking-refactor/21-CONTEXT.md
@.planning/phases/21-language-chunking-refactor/21-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create handlers package with Protocol and registry</name>
  <files>src/cocosearch/handlers/__init__.py</files>
  <action>
    Create new handlers package with:

    1. **Shared types** (defined BEFORE discovery to avoid circular imports):
       - `ChunkConfig` dataclass with chunk_size: int, chunk_overlap: int
       - `Chunk` dataclass with text: str, location: dict, metadata: dict
       - `LanguageHandler` Protocol with:
         - EXTENSIONS: ClassVar[list[str]] - file extensions with leading dot (e.g., ['.tf'])
         - SEPARATOR_SPEC: ClassVar[cocoindex.functions.CustomLanguageSpec] - CocoIndex chunking spec
         - def extract_metadata(self, text: str) -> dict - extract block_type, hierarchy, language_id

    2. **Autodiscovery function** `_discover_handlers()`:
       - Use pathlib.glob("*.py") to scan handlers/ directory
       - Skip files starting with underscore (_template.py, __init__.py)
       - Import modules using importlib.import_module
       - Find classes with EXTENSIONS and extract_metadata attributes (duck typing)
       - Build extension-to-handler dict mapping
       - Fail fast with ValueError on extension conflicts
       - Log registration with logging.info

    3. **Run discovery at module import**:
       - Call _discover_handlers() at module level
       - Store result in _HANDLER_REGISTRY

    4. **Public API**:
       - get_handler(extension: str) -> LanguageHandler - returns handler or TextHandler fallback
       - get_custom_languages() -> list[CustomLanguageSpec] - returns all SEPARATOR_SPEC from registered handlers
       - __all__ with LanguageHandler, ChunkConfig, Chunk, get_handler, get_custom_languages

    NOTE: The Protocol uses SEPARATOR_SPEC and extract_metadata() instead of chunk() because CocoIndex
    transforms run in Rust. The flow.py will call SplitRecursively with handler's SEPARATOR_SPEC, then
    call extract_metadata() as a separate Python transform.
  </action>
  <verify>
    - `python -c "from cocosearch.handlers import LanguageHandler, ChunkConfig, Chunk, get_handler"`
    - Verify Protocol is importable
    - Verify registry discovery runs without error (text.py must exist first)
  </verify>
  <done>
    handlers/__init__.py defines Protocol, shared types, registry autodiscovery, and public API.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create default text handler and template</name>
  <files>src/cocosearch/handlers/text.py, src/cocosearch/handlers/_template.py</files>
  <action>
    Create text.py with TextHandler class:

    ```python
    class TextHandler:
        """Default handler for plain text files (fallback)."""

        EXTENSIONS: ClassVar[list[str]] = []  # No specific extensions - used as fallback

        # No SEPARATOR_SPEC - uses CocoIndex default text splitting
        SEPARATOR_SPEC = None

        def extract_metadata(self, text: str) -> dict:
            """Return empty metadata for plain text."""
            return {"block_type": "", "hierarchy": "", "language_id": ""}
    ```

    Create _template.py (underscore prefix excludes from autodiscovery):

    - Include comprehensive docstring explaining how to create new handlers
    - TemplateHandler class with TODO comments for:
      - EXTENSIONS list
      - SEPARATOR_SPEC with CustomLanguageSpec
      - extract_metadata() implementation
    - Include example regex patterns and metadata extraction from RESEARCH.md
    - Reference handlers/README.md for full documentation
  </action>
  <verify>
    - `python -c "from cocosearch.handlers.text import TextHandler; h = TextHandler(); print(h.EXTENSIONS)"`
    - Verify TextHandler can be instantiated
    - Verify _template.py is valid Python: `python -c "import sys; sys.path.insert(0, 'src'); exec(open('src/cocosearch/handlers/_template.py').read())"`
  </verify>
  <done>
    TextHandler provides fallback for unrecognized extensions.
    _template.py provides documented starting point for new language handlers.
  </done>
</task>

</tasks>

<verification>
Run from project root:

```bash
# Verify package structure
ls -la src/cocosearch/handlers/

# Verify imports work
python -c "
from cocosearch.handlers import LanguageHandler, ChunkConfig, Chunk, get_handler, get_custom_languages
print('Imports OK')
h = get_handler('.unknown')
print(f'Fallback handler: {h.__class__.__name__}')
print(f'Custom languages: {len(get_custom_languages())}')
"

# Verify _template is excluded from discovery
python -c "
from cocosearch.handlers import _HANDLER_REGISTRY
print(f'Registered handlers: {list(_HANDLER_REGISTRY.keys())}')
# Should be empty at this point (no language handlers yet)
"
```
</verification>

<success_criteria>
1. handlers/__init__.py exists with Protocol, types, registry, and public API
2. text.py exists with TextHandler fallback
3. _template.py exists with documented template
4. Package imports without errors
5. get_handler() returns TextHandler for unknown extensions
</success_criteria>

<output>
After completion, create `.planning/phases/21-language-chunking-refactor/21-01-SUMMARY.md`
</output>
