---
phase: 05-test-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/mocks/__init__.py
  - tests/mocks/db.py
  - tests/fixtures/__init__.py
  - tests/fixtures/db.py
autonomous: true

must_haves:
  truths:
    - "Tests can mock database connections without real PostgreSQL"
    - "Mock cursor tracks executed queries for assertions"
    - "Mock pool integrates with patched get_connection_pool"
  artifacts:
    - path: "tests/mocks/db.py"
      provides: "MockCursor, MockConnection, MockConnectionPool classes"
      min_lines: 60
    - path: "tests/fixtures/db.py"
      provides: "mock_db_pool and patched_db_pool fixtures"
      min_lines: 30
  key_links:
    - from: "tests/fixtures/db.py"
      to: "cocosearch.search.db.get_connection_pool"
      via: "unittest.mock.patch"
      pattern: "patch.*get_connection_pool"
---

<objective>
Create PostgreSQL mocking infrastructure for isolated database testing.

Purpose: Enable tests to run without a real PostgreSQL database by providing mock connection pools with call tracking.
Output: Mock database classes and pytest fixtures for database testing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-test-infrastructure/05-CONTEXT.md
@.planning/phases/05-test-infrastructure/05-RESEARCH.md
@src/cocosearch/search/db.py
@src/cocosearch/search/query.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database mock classes</name>
  <files>tests/mocks/__init__.py, tests/mocks/db.py</files>
  <action>
Create tests/mocks/ directory with:

1. tests/mocks/__init__.py - empty file to make mocks a package

2. tests/mocks/db.py - mock database classes:
```python
"""Database mock classes for testing.

Provides MockCursor, MockConnection, and MockConnectionPool that mimic
psycopg/psycopg_pool interfaces without requiring a real database.
"""

from typing import Any
from collections.abc import Sequence


class MockCursor:
    """Mock database cursor with call tracking.

    Tracks all executed queries and parameters for assertion in tests.
    Returns canned results configured at construction.
    """

    def __init__(self, results: Sequence[tuple] | None = None):
        """Initialize mock cursor with optional canned results.

        Args:
            results: List of tuples to return from fetch methods.
        """
        self.results = list(results) if results else []
        self.calls: list[tuple[str, tuple | None]] = []
        self._fetch_index = 0

    def execute(self, query: str, params: tuple | None = None) -> None:
        """Record query execution for later assertions."""
        self.calls.append((query, params))

    def fetchone(self) -> tuple | None:
        """Return next result row."""
        if self._fetch_index < len(self.results):
            row = self.results[self._fetch_index]
            self._fetch_index += 1
            return row
        return None

    def fetchall(self) -> list[tuple]:
        """Return all remaining results."""
        remaining = self.results[self._fetch_index:]
        self._fetch_index = len(self.results)
        return remaining

    def __enter__(self) -> "MockCursor":
        return self

    def __exit__(self, *args: Any) -> None:
        pass

    def assert_query_contains(self, substring: str) -> None:
        """Assert that any executed query contains substring."""
        for query, _ in self.calls:
            if substring in query:
                return
        raise AssertionError(f"No query containing '{substring}' was executed. Queries: {[q for q, _ in self.calls]}")

    def assert_called_with_param(self, param: Any) -> None:
        """Assert that any query was called with a specific parameter."""
        for _, params in self.calls:
            if params and param in params:
                return
        raise AssertionError(f"No query called with parameter '{param}'")


class MockConnection:
    """Mock database connection."""

    def __init__(self, cursor: MockCursor | None = None):
        """Initialize with optional pre-configured cursor."""
        self._cursor = cursor or MockCursor()

    def cursor(self) -> MockCursor:
        """Return the mock cursor."""
        return self._cursor

    def __enter__(self) -> "MockConnection":
        return self

    def __exit__(self, *args: Any) -> None:
        pass


class MockConnectionPool:
    """Mock psycopg_pool.ConnectionPool.

    Mimics the connection() context manager interface.
    """

    def __init__(self, connection: MockConnection | None = None):
        """Initialize with optional pre-configured connection."""
        self._connection = connection or MockConnection()

    def connection(self) -> MockConnection:
        """Return a context manager yielding the mock connection."""
        return self._connection
```

Note: The actual psycopg_pool uses a context manager pattern where pool.connection() returns a context manager. Our mock implements __enter__/__exit__ on MockConnection to support this pattern.
  </action>
  <verify>
Run: `uv run python -c "from tests.mocks.db import MockCursor, MockConnection, MockConnectionPool; print('ok')"`
  </verify>
  <done>
tests/mocks/db.py exists with MockCursor, MockConnection, MockConnectionPool classes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create database fixtures</name>
  <files>tests/fixtures/__init__.py, tests/fixtures/db.py</files>
  <action>
Create tests/fixtures/ directory with:

1. tests/fixtures/__init__.py - empty file to make fixtures a package

2. tests/fixtures/db.py - pytest fixtures for database mocking:
```python
"""Database fixtures for testing.

Provides fixtures that mock cocosearch.search.db module functions
to enable testing without a real PostgreSQL database.
"""

import pytest
from unittest.mock import patch

from tests.mocks.db import MockConnectionPool, MockCursor, MockConnection


@pytest.fixture
def mock_db_pool():
    """Factory fixture for creating mock database pools.

    Returns a function that creates a configured (pool, cursor) tuple.
    The cursor can be pre-loaded with results for testing.

    Usage:
        def test_something(mock_db_pool):
            pool, cursor = mock_db_pool(results=[
                ("/path/file.py", 0, 100, 0.85),
            ])
            # Use pool in test...
            cursor.assert_query_contains("SELECT")
    """
    def _make_pool(results: list[tuple] | None = None) -> tuple[MockConnectionPool, MockCursor]:
        cursor = MockCursor(results=results)
        conn = MockConnection(cursor=cursor)
        pool = MockConnectionPool(connection=conn)
        return pool, cursor

    return _make_pool


@pytest.fixture
def patched_db_pool(mock_db_pool):
    """Fixture that auto-patches get_connection_pool.

    Patches cocosearch.search.db.get_connection_pool to return a mock pool.
    Returns (pool, cursor) for test assertions.

    Usage:
        def test_search(patched_db_pool):
            pool, cursor = patched_db_pool
            # Now any code calling get_connection_pool() gets the mock
    """
    pool, cursor = mock_db_pool()
    with patch('cocosearch.search.db.get_connection_pool', return_value=pool):
        yield pool, cursor


@pytest.fixture
def mock_search_results():
    """Sample search results for testing.

    Returns a list of tuples in the format returned by search queries:
    (filename, start_byte, end_byte, score)
    """
    return [
        ("/path/to/main.py", 0, 150, 0.92),
        ("/path/to/utils.py", 50, 200, 0.85),
        ("/path/to/config.py", 100, 250, 0.78),
    ]
```

Then update tests/conftest.py to register the db fixtures plugin:
- Uncomment the "tests.fixtures.db" line in pytest_plugins list
  </action>
  <verify>
Run: `uv run python -c "from tests.fixtures.db import mock_db_pool, patched_db_pool; print('ok')"`
  </verify>
  <done>
tests/fixtures/db.py exists with mock_db_pool and patched_db_pool fixtures
tests/conftest.py registers tests.fixtures.db in pytest_plugins
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify database mocking works</name>
  <files>tests/test_db_mocks.py</files>
  <action>
Create tests/test_db_mocks.py to verify the database mocking infrastructure:

```python
"""Tests to verify database mocking infrastructure works correctly."""

import pytest


def test_mock_cursor_tracks_queries(mock_db_pool):
    """Verify MockCursor tracks executed queries."""
    pool, cursor = mock_db_pool()

    cursor.execute("SELECT * FROM test WHERE id = %s", (1,))
    cursor.execute("INSERT INTO test VALUES (%s)", ("value",))

    assert len(cursor.calls) == 2
    cursor.assert_query_contains("SELECT")
    cursor.assert_query_contains("INSERT")


def test_mock_cursor_returns_results(mock_db_pool):
    """Verify MockCursor returns configured results."""
    results = [
        ("/path/file1.py", 0, 100, 0.9),
        ("/path/file2.py", 50, 150, 0.8),
    ]
    pool, cursor = mock_db_pool(results=results)

    cursor.execute("SELECT * FROM test")
    rows = cursor.fetchall()

    assert len(rows) == 2
    assert rows[0][0] == "/path/file1.py"
    assert rows[1][3] == 0.8


def test_mock_cursor_fetchone(mock_db_pool):
    """Verify MockCursor fetchone returns rows one at a time."""
    results = [("row1",), ("row2",)]
    pool, cursor = mock_db_pool(results=results)

    cursor.execute("SELECT * FROM test")
    assert cursor.fetchone() == ("row1",)
    assert cursor.fetchone() == ("row2",)
    assert cursor.fetchone() is None


def test_mock_pool_context_manager(mock_db_pool):
    """Verify MockConnectionPool works as context manager."""
    pool, cursor = mock_db_pool(results=[("test",)])

    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute("SELECT 1")
            result = cur.fetchone()

    assert result == ("test",)


def test_patched_db_pool_patches_module(patched_db_pool):
    """Verify patched_db_pool patches the actual module."""
    from cocosearch.search.db import get_connection_pool

    pool, cursor = patched_db_pool
    actual_pool = get_connection_pool()

    # Should return our mock, not try to connect to real DB
    assert actual_pool is pool


def test_mock_search_results_fixture(mock_search_results):
    """Verify mock_search_results provides sample data."""
    assert len(mock_search_results) == 3
    assert mock_search_results[0][0] == "/path/to/main.py"
    assert mock_search_results[0][3] == 0.92  # score
```

Run pytest to verify all tests pass.
  </action>
  <verify>
Run: `uv run pytest tests/test_db_mocks.py -v` passes all 6 tests
  </verify>
  <done>
Database mocking infrastructure verified with passing tests
  </done>
</task>

</tasks>

<verification>
All verification commands should pass:
```bash
# Mock classes importable
uv run python -c "from tests.mocks.db import MockCursor, MockConnection, MockConnectionPool; print('ok')"

# Fixtures importable
uv run python -c "from tests.fixtures.db import mock_db_pool; print('ok')"

# All mock tests pass
uv run pytest tests/test_db_mocks.py -v
```
</verification>

<success_criteria>
- tests/mocks/db.py has MockCursor, MockConnection, MockConnectionPool classes
- tests/fixtures/db.py has mock_db_pool, patched_db_pool, mock_search_results fixtures
- MockCursor tracks queries and returns canned results
- patched_db_pool correctly patches cocosearch.search.db.get_connection_pool
- All tests in tests/test_db_mocks.py pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-test-infrastructure/05-02-SUMMARY.md`
</output>
