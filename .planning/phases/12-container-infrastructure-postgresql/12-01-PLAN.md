---
phase: 12-container-infrastructure-postgresql
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/docker-compose.test.yml
  - tests/fixtures/containers.py
  - tests/integration/conftest.py
autonomous: true

must_haves:
  truths:
    - "Docker availability check fails early with clear message when Docker not running"
    - "PostgreSQL container starts with pgvector image on port 5433"
    - "Container health check ensures PostgreSQL ready before tests execute"
  artifacts:
    - path: "tests/docker-compose.test.yml"
      provides: "PostgreSQL container configuration"
      contains: "pgvector/pgvector:pg16"
    - path: "tests/fixtures/containers.py"
      provides: "Session-scoped container fixtures"
      exports: ["postgres_container", "test_db_url"]
    - path: "tests/integration/conftest.py"
      provides: "Integration test configuration with Docker check"
      contains: "pytest_configure"
  key_links:
    - from: "tests/fixtures/containers.py"
      to: "tests/docker-compose.test.yml"
      via: "testcontainers reads compose config"
      pattern: "PostgresContainer"
    - from: "tests/integration/conftest.py"
      to: "tests/fixtures/containers.py"
      via: "pytest_plugins import"
      pattern: "tests.fixtures.containers"
---

<objective>
Create Docker container infrastructure for PostgreSQL integration testing.

Purpose: Enable integration tests to use real PostgreSQL+pgvector instead of mocks, validating actual database behavior.

Output:
- docker-compose.test.yml with PostgreSQL+pgvector configuration
- Container fixtures for session-scoped PostgreSQL container
- Docker availability check that fails fast with helpful message
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-container-infrastructure-postgresql/12-CONTEXT.md
@.planning/phases/12-container-infrastructure-postgresql/12-RESEARCH.md
@tests/conftest.py
@tests/integration/conftest.py
@src/cocosearch/search/db.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create docker-compose.test.yml for PostgreSQL container</name>
  <files>tests/docker-compose.test.yml</files>
  <action>
Create docker-compose.test.yml in tests/ directory with PostgreSQL+pgvector configuration:

```yaml
# PostgreSQL container configuration for integration tests
# Used by testcontainers to configure test database

services:
  postgres:
    image: pgvector/pgvector:pg16
    ports:
      - "5433:5432"
    environment:
      POSTGRES_USER: cocosearch_test
      POSTGRES_PASSWORD: test_password
      POSTGRES_DB: cocosearch_test
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U cocosearch_test -d cocosearch_test"]
      interval: 5s
      timeout: 5s
      retries: 5
```

Key decisions (from CONTEXT.md):
- Port 5433 avoids conflict with local PostgreSQL on 5432
- Pin exact image pgvector/pgvector:pg16 for reproducibility
- Fixed database name cocosearch_test for predictability
- Health check uses pg_isready for reliable readiness detection
  </action>
  <verify>File exists at tests/docker-compose.test.yml with correct structure</verify>
  <done>docker-compose.test.yml created with PostgreSQL+pgvector configuration</done>
</task>

<task type="auto">
  <name>Task 2: Create container fixtures module</name>
  <files>tests/fixtures/containers.py</files>
  <action>
Create tests/fixtures/containers.py with session-scoped PostgreSQL container fixture:

```python
"""Container fixtures for integration testing.

Provides session-scoped PostgreSQL container using testcontainers-python.
Container starts once per test session and is reused across all integration tests.
"""

import os
import pytest
from testcontainers.postgres import PostgresContainer

# Environment variable configuration with defaults (CONTEXT.md decision)
TEST_DB_PORT = int(os.getenv("COCOSEARCH_TEST_DB_PORT", "5433"))
TEST_DB_USER = os.getenv("COCOSEARCH_TEST_DB_USER", "cocosearch_test")
TEST_DB_PASSWORD = os.getenv("COCOSEARCH_TEST_DB_PASSWORD", "test_password")
TEST_DB_NAME = os.getenv("COCOSEARCH_TEST_DB_NAME", "cocosearch_test")


@pytest.fixture(scope="session")
def postgres_container():
    """Start PostgreSQL container for entire test session.

    Locked decisions from Phase 12 CONTEXT:
    - Session scope (one container for all tests)
    - 60s timeout (handles slow CI, first pull)
    - Pin pg16 (reproducible, explicit upgrades)
    - Port 5433 (avoid local PostgreSQL on 5432)
    """
    with PostgresContainer(
        image="pgvector/pgvector:pg16",
        port=5433,
        user=TEST_DB_USER,
        password=TEST_DB_PASSWORD,
        dbname=TEST_DB_NAME,
    ).with_env("POSTGRES_HOST_AUTH_METHOD", "trust") as postgres:
        # Wait for container ready (testcontainers handles this automatically)
        yield postgres


@pytest.fixture(scope="session")
def test_db_url(postgres_container):
    """Get connection URL for test database.

    Returns psycopg3-compatible connection URL.
    """
    return postgres_container.get_connection_url(driver=None)
```

Key implementation notes:
- Session scope ensures one container for all tests (performance)
- Environment variable defaults allow CI override
- testcontainers handles automatic cleanup via Ryuk
- driver=None returns psycopg3-compatible URL
  </action>
  <verify>File exists and imports correctly: python -c "from tests.fixtures.containers import postgres_container, test_db_url"</verify>
  <done>Container fixtures module created with session-scoped PostgreSQL fixture</done>
</task>

<task type="auto">
  <name>Task 3: Update integration conftest.py with Docker availability check</name>
  <files>tests/integration/conftest.py</files>
  <action>
Update tests/integration/conftest.py to:
1. Add Docker availability check in pytest_configure
2. Register container fixtures plugin
3. Keep existing integration marker auto-apply

```python
"""Integration test conftest.py - Docker checks and auto-apply integration marker."""

import pytest

# Register container fixtures for integration tests
pytest_plugins = ["tests.fixtures.containers"]


def pytest_configure(config):
    """Check Docker availability at test session start.

    Locked decision from CONTEXT.md: "Fail immediately if Docker unavailable â€”
    hard error forces Docker availability"

    Only check when running integration tests (not unit tests).
    """
    # Only check Docker when running integration tests
    if config.option.markexpr and "integration" in config.option.markexpr:
        try:
            import docker
            client = docker.from_env()
            client.ping()
        except Exception as e:
            pytest.exit(
                f"Docker is not available: {e}\n\n"
                f"Integration tests require Docker to be installed and running.\n"
                f"Install Docker: https://docs.docker.com/get-docker/\n\n"
                f"To run unit tests only (no Docker required):\n"
                f"  pytest -m unit",
                returncode=1
            )


def pytest_collection_modifyitems(items):
    """Add integration marker to all tests in tests/integration/."""
    for item in items:
        if "/integration/" in str(item.fspath):
            item.add_marker(pytest.mark.integration)
```

Key decisions:
- Docker check only runs when explicitly running integration tests
- Clear error message with instructions for running unit tests instead
- Preserves existing marker auto-apply behavior
  </action>
  <verify>Run: pytest tests/integration/ --collect-only 2>&1 | head -20 (should show Docker check or collection)</verify>
  <done>Integration conftest.py updated with Docker availability check and container fixtures</done>
</task>

</tasks>

<verification>
1. docker-compose.test.yml exists with PostgreSQL+pgvector configuration
2. Container fixtures module has session-scoped postgres_container fixture
3. Docker availability check fails with helpful message when Docker not available
4. Files import correctly without errors
</verification>

<success_criteria>
- docker-compose.test.yml created with pgvector/pgvector:pg16 image on port 5433
- tests/fixtures/containers.py exports postgres_container and test_db_url fixtures
- tests/integration/conftest.py checks Docker availability before running integration tests
- All imports work without errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-container-infrastructure-postgresql/12-01-SUMMARY.md`
</output>
