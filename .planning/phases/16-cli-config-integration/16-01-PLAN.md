---
phase: 16-cli-config-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/cocosearch/config/resolver.py
  - src/cocosearch/config/__init__.py
  - tests/unit/config/test_resolver.py
autonomous: true

must_haves:
  truths:
    - "CLI flag value takes precedence over env var value"
    - "Env var value takes precedence over config file value"
    - "Config file value takes precedence over default"
    - "Source is tracked for each resolved value"
    - "Environment variables are correctly parsed to their target types"
  artifacts:
    - path: "src/cocosearch/config/resolver.py"
      provides: "ConfigResolver class with precedence resolution"
      exports: ["ConfigResolver", "config_key_to_env_var", "parse_env_value"]
    - path: "tests/unit/config/test_resolver.py"
      provides: "Unit tests for resolver precedence logic"
      min_lines: 100
  key_links:
    - from: "src/cocosearch/config/resolver.py"
      to: "CocoSearchConfig"
      via: "import from schema"
      pattern: "from.*schema.*import.*CocoSearchConfig"
---

<objective>
Implement ConfigResolver with CLI > env > config > default precedence using TDD

Purpose: The resolver is the core logic for Phase 16's requirement (CONF-09) that CLI flags override config file settings. This has clear input/output behavior that benefits from test-first development.

Output: Working ConfigResolver class with source tracking and type-aware env var parsing
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-cli-config-integration/16-CONTEXT.md
@.planning/phases/16-cli-config-integration/16-RESEARCH.md

# Prior phase provides config schema
@src/cocosearch/config/schema.py
@src/cocosearch/config/__init__.py
</context>

<feature>
  <name>ConfigResolver precedence resolution</name>
  <files>src/cocosearch/config/resolver.py, tests/unit/config/test_resolver.py</files>
  <behavior>
    ConfigResolver takes a CocoSearchConfig and provides resolved values with source tracking.

    Cases (resolve method):
    - resolve("indexName", cli="my-cli", env="COCOSEARCH_INDEX_NAME") -> ("my-cli", "CLI flag")
    - resolve("indexName", cli=None, env="COCOSEARCH_INDEX_NAME") with env set -> (env_value, "env:COCOSEARCH_INDEX_NAME")
    - resolve("indexName", cli=None, env="COCOSEARCH_INDEX_NAME") with env unset -> (config_value, "config:/path/to/yaml")
    - resolve("indexName", cli=None, env="COCOSEARCH_INDEX_NAME") with no config -> (None, "default")

    Cases (config_key_to_env_var):
    - "indexName" -> "COCOSEARCH_INDEX_NAME"
    - "indexing.chunkSize" -> "COCOSEARCH_INDEXING_CHUNK_SIZE"

    Cases (parse_env_value):
    - ("100", int) -> 100
    - ("0.5", float) -> 0.5
    - ("true", bool) -> True
    - ("false", bool) -> False
    - ('["*.py", "*.js"]', list[str]) -> ["*.py", "*.js"]
    - ("*.py,*.js", list[str]) -> ["*.py", "*.js"] (comma fallback)
  </behavior>
  <implementation>
    Create src/cocosearch/config/resolver.py with:

    1. config_key_to_env_var(config_key: str) -> str
       - Split on dots for nested keys
       - Convert camelCase to UPPER_SNAKE_CASE using regex
       - Prefix with COCOSEARCH_

    2. parse_env_value(raw: str, field_type: type) -> Any
       - Handle bool: "true"/"1"/"yes" -> True
       - Handle int: int(raw)
       - Handle float: float(raw)
       - Handle list: Try JSON parse first, fallback to comma-split
       - Handle None indicators: ""/"null"/"none" -> None

    3. class ConfigResolver:
       def __init__(self, config: CocoSearchConfig, config_path: Path | None = None):
           self.config = config
           self.config_path = config_path
           self._cache: dict[str, tuple[Any, str]] = {}

       def resolve(self, field_path: str, cli_value: Any | None, env_var: str) -> tuple[Any, str]:
           # Priority 1: CLI flag
           if cli_value is not None:
               return cli_value, "CLI flag"
           # Priority 2: Env var
           env_value = os.environ.get(env_var)
           if env_value is not None:
               field_type = self._get_field_type(field_path)
               return parse_env_value(env_value, field_type), f"env:{env_var}"
           # Priority 3: Config file
           config_value = self._get_config_value(field_path)
           if config_value is not None:
               source = f"config:{self.config_path}" if self.config_path else "config"
               return config_value, source
           # Priority 4: Default
           return self._get_default_value(field_path), "default"

       def _get_config_value(self, field_path: str) -> Any:
           # Navigate nested config via dot notation
           ...

       def _get_field_type(self, field_path: str) -> type:
           # Get type hint from Pydantic model field
           ...

       def _get_default_value(self, field_path: str) -> Any:
           # Get default from Pydantic model
           ...

       def all_field_paths(self) -> list[str]:
           # Return all resolvable field paths for iteration
           ...
  </implementation>
</feature>

<verification>
Run tests: `pytest tests/unit/config/test_resolver.py -v`
All tests pass
Import check: `python -c "from cocosearch.config import ConfigResolver"`
</verification>

<success_criteria>
- ConfigResolver correctly resolves values through precedence chain
- Source tracking returns accurate source for each resolution
- Environment variable parsing handles int, float, bool, list types
- All tests pass (RED -> GREEN cycle completed)
- Exported from cocosearch.config module
</success_criteria>

<output>
After completion, create `.planning/phases/16-cli-config-integration/16-01-SUMMARY.md`
</output>
