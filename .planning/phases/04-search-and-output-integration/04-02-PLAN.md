---
phase: 04-search-and-output-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/cocosearch/search/formatter.py
  - src/cocosearch/mcp/server.py
  - tests/search/test_formatter.py
  - tests/mcp/test_server.py
autonomous: true

must_haves:
  truths:
    - "JSON output includes block_type, hierarchy, language_id for every result"
    - "Pretty output shows [language] annotation prefix before code blocks"
    - "Pretty output shows hierarchy in annotation when available (e.g., [hcl] resource.aws_s3_bucket.data)"
    - "Non-DevOps files show language tag derived from extension (e.g., [python])"
    - "Syntax highlighting works for HCL, Dockerfile, and Bash in pretty output"
    - "MCP search_code response includes block_type, hierarchy, language_id fields"
    - "MCP search_code accepts optional language parameter for DevOps filtering"
    - "Pre-v1.2 results (empty metadata) show consistent shape in JSON, pretty, and MCP"
  artifacts:
    - path: "src/cocosearch/search/formatter.py"
      provides: "JSON and pretty formatters with metadata annotations and DevOps syntax highlighting"
      contains: "block_type"
    - path: "src/cocosearch/mcp/server.py"
      provides: "MCP search_code with metadata fields in response"
      contains: "block_type"
    - path: "tests/search/test_formatter.py"
      provides: "Tests for metadata in JSON output and annotation in pretty output"
      contains: "test_json_includes_metadata"
    - path: "tests/mcp/test_server.py"
      provides: "Tests for metadata in MCP response"
      contains: "block_type"
  key_links:
    - from: "src/cocosearch/search/formatter.py"
      to: "SearchResult.block_type"
      via: "r.block_type attribute access"
      pattern: "r\\.block_type"
    - from: "src/cocosearch/search/formatter.py"
      to: "SearchResult.language_id"
      via: "r.language_id for syntax highlighting"
      pattern: "r\\.language_id"
    - from: "src/cocosearch/mcp/server.py"
      to: "SearchResult metadata fields"
      via: "dict construction from r.block_type, r.hierarchy, r.language_id"
      pattern: "block_type.*r\\.block_type"
---

<objective>
Update all output consumers (JSON formatter, pretty formatter, MCP server) to surface DevOps metadata from the extended SearchResult. Add annotation prefixes to pretty output, syntax highlighting for DevOps languages, and metadata fields to MCP responses.

Purpose: This is the user-facing layer. Without it, metadata stored in PostgreSQL is invisible to users and LLMs. The annotation format ([hcl] resource.aws_s3_bucket.data) makes infrastructure search results immediately scannable.

Output: Updated `formatter.py` with metadata in JSON and annotations in pretty output. Updated `server.py` with metadata in MCP response. Tests for all changes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-search-and-output-integration/04-CONTEXT.md
@.planning/phases/04-search-and-output-integration/04-01-SUMMARY.md
@src/cocosearch/search/formatter.py
@src/cocosearch/mcp/server.py
@src/cocosearch/search/query.py
@tests/search/test_formatter.py
@tests/mcp/test_server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add metadata to JSON output and update pretty output with annotations</name>
  <files>src/cocosearch/search/formatter.py</files>
  <action>
  1. **Update `format_json()`** to include metadata fields in every result dict:
     - After the `"score"` key, add:
       ```python
       "block_type": r.block_type,
       "hierarchy": r.hierarchy,
       "language_id": r.language_id,
       ```
     - These fields always appear (empty strings for non-DevOps/pre-v1.2, filled for DevOps). This ensures consistent JSON shape per project convention.

  2. **Add DevOps entries to `EXTENSION_LANG_MAP`** (REQ-26 syntax highlighting):
     - Add `"tf": "hcl"` (Pygments recognizes "hcl" for Terraform syntax)
     - Add `"hcl": "hcl"`
     - Add `"tfvars": "hcl"`
     NOTE: Dockerfile and Bash (.sh, .bash, .zsh) are already covered by existing entries in the map. Rich/Pygments uses "docker" for Dockerfile syntax, but Dockerfiles are extensionless -- we handle them via language_id below.

  3. **Update `format_pretty()`** to show annotation prefix and use language_id for highlighting:

     a. **Determine display language for each result**: Create a helper function `_get_display_language(result: SearchResult, filepath: str) -> str`:
        - If `result.language_id` is non-empty: return `result.language_id` (e.g., "hcl", "dockerfile", "bash")
        - Else: derive from file extension using EXTENSION_LANG_MAP, falling back to extension itself
        - This ensures DevOps files identified by language_id get correct language tags even without file extensions (Dockerfile)

     b. **Build annotation string**: Create helper `_get_annotation(result: SearchResult, display_lang: str) -> str`:
        - If `result.hierarchy` is non-empty: return `[{display_lang}] {result.hierarchy}` (e.g., "[hcl] resource.aws_s3_bucket.data")
        - Else: return `[{display_lang}]` (e.g., "[python]")

     c. **In the result rendering loop** (inside `for r in file_results:`), after the score/line info line:
        - Call `_get_display_language(r, filepath)` and `_get_annotation(r, display_lang)`
        - Print annotation on a new line: `console.print(f"  [dim cyan]{annotation}[/dim cyan]")`
        - Place this BETWEEN the score line and the code content

     d. **Use language_id for syntax highlighting**: Replace the existing extension-based language detection:
        ```python
        # Before (extension-only):
        ext = os.path.splitext(filepath)[1].lstrip(".")
        lang = EXTENSION_LANG_MAP.get(ext, ext)

        # After (language_id preferred):
        lang = _get_display_language(r, filepath)
        ```
        Then map to Pygments lexer name for Rich Syntax:
        - "hcl" -> "hcl" (Pygments has HCL lexer)
        - "dockerfile" -> "docker" (Pygments lexer name)
        - "bash" -> "bash" (already correct)
        - Others: use EXTENSION_LANG_MAP as before

        Create a small mapping `_PYGMENTS_LEXER_MAP = {"dockerfile": "docker"}` for cases where display name differs from Pygments lexer name. Use: `lexer = _PYGMENTS_LEXER_MAP.get(lang, lang)`.
  </action>
  <verify>
  Run `python -c "from cocosearch.search.formatter import EXTENSION_LANG_MAP; assert EXTENSION_LANG_MAP['tf'] == 'hcl'"` -- new entries exist.
  Run `python -c "from cocosearch.search.formatter import _get_annotation; print('exists')"` -- helper function importable (or verify indirectly via test).
  </verify>
  <done>
  - format_json includes block_type, hierarchy, language_id in every result dict
  - EXTENSION_LANG_MAP has tf, hcl, tfvars entries
  - format_pretty shows [language] annotation prefix before code
  - format_pretty shows hierarchy in annotation when non-empty
  - DevOps files use language_id for syntax highlighting (not extension)
  - Dockerfile syntax highlighting uses "docker" Pygments lexer
  - Non-DevOps files show extension-derived language tag
  </done>
</task>

<task type="auto">
  <name>Task 2: Add metadata fields to MCP search_code response</name>
  <files>src/cocosearch/mcp/server.py</files>
  <action>
  1. **Update `search_code()` response dict** to include metadata fields:
     In the result dict construction loop (inside `for r in results:`), add after the `"content"` key:
     ```python
     "block_type": r.block_type,
     "hierarchy": r.hierarchy,
     "language_id": r.language_id,
     ```
     These fields are always present with empty strings when metadata is unavailable (consistent shape for LLM consumers).

  2. **Update the `language` parameter description** in the `search_code` function signature:
     Change the Field description from:
     ```python
     Field(description="Filter by language (e.g., python, typescript)")
     ```
     to:
     ```python
     Field(description="Filter by language (e.g., python, typescript, hcl, dockerfile, bash). Comma-separated for multiple.")
     ```
     This documents the new DevOps language support and multi-language capability added in Plan 01.

  3. The `language` parameter already passes through to `search()` via `language_filter=language`, so the DevOps filtering logic from Plan 01 is automatically available. No additional wiring needed.
  </action>
  <verify>
  Run `python -c "from cocosearch.mcp.server import search_code; print('imports ok')"` -- module loads without error.
  </verify>
  <done>
  - MCP search_code response includes block_type, hierarchy, language_id in every result dict
  - Language parameter description updated to mention DevOps languages and comma support
  - Metadata fields use empty strings when unavailable (consistent shape)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for formatter metadata and MCP metadata response</name>
  <files>tests/search/test_formatter.py, tests/mcp/test_server.py</files>
  <action>
  **In `tests/search/test_formatter.py`:**

  1. Update the import to include `_get_display_language` and `_get_annotation` if they are module-level functions (or test indirectly via format_json/format_pretty).

  2. **New class TestFormatJsonMetadata:**
     - `test_json_includes_metadata_fields`: Create SearchResult with block_type="resource", hierarchy="resource.aws_s3_bucket.data", language_id="hcl". Call format_json. Parse JSON. Assert item has "block_type" == "resource", "hierarchy" == "resource.aws_s3_bucket.data", "language_id" == "hcl".
     - `test_json_empty_metadata_for_non_devops`: Create SearchResult with defaults (empty strings). Call format_json. Assert "block_type" == "", "hierarchy" == "", "language_id" == "".
     - `test_json_metadata_consistent_shape`: Verify both DevOps and non-DevOps results have identical key sets (same shape).

  3. **New class TestFormatPrettyAnnotation:**
     - `test_shows_language_annotation`: Create SearchResult with language_id="hcl", hierarchy="resource.aws_s3_bucket.data". Call format_pretty. Assert output contains "[hcl] resource.aws_s3_bucket.data".
     - `test_shows_language_only_without_hierarchy`: Create SearchResult with language_id="hcl", hierarchy="". Assert output contains "[hcl]" but not "resource".
     - `test_non_devops_shows_extension_language`: Create SearchResult for a .py file with empty language_id. Assert output contains "[python]".
     - `test_dockerfile_syntax_highlighting_uses_docker_lexer`: Create SearchResult with language_id="dockerfile". Verify format_pretty doesn't raise (Pygments "docker" lexer works). Check output has content rendered.

  4. **New class TestExtensionLangMapDevOps:**
     - `test_hcl_extensions`: Assert EXTENSION_LANG_MAP["tf"] == "hcl", same for "hcl", "tfvars".

  Use the existing `make_search_result` fixture. The fixture creates SearchResult -- it will need to handle the new default fields. Check if the fixture uses `SearchResult(...)` directly or a factory. If it uses positional args, update it to use keyword args or add the new fields.

  NOTE: The `make_search_result` fixture likely lives in `tests/conftest.py`. If it creates SearchResult with positional args only (filename, start_byte, end_byte, score), it will still work because the new fields have defaults. No fixture change needed.

  **In `tests/mcp/test_server.py`:**

  5. **Update TestSearchCode:**
     - `test_response_includes_metadata`: Mock DB to return rows with 7 columns (including metadata). Call search_code. Assert result dict contains "block_type", "hierarchy", "language_id".
     - `test_response_empty_metadata_for_non_devops`: Mock DB to return rows where metadata columns are empty strings. Assert result dict has "block_type" == "", etc.

  For MCP tests, the mock DB needs to return 7-column rows (filename, start_byte, end_byte, score, block_type, hierarchy, language_id) instead of 4-column rows. Update `mock_db_pool` results accordingly in the new tests. Existing tests may need the row format updated too -- check if the mock returns raw tuples. If so, the existing tests that return 4-tuple rows will trigger the graceful degradation path (UndefinedColumn fallback), which is actually a valid test scenario. However, to avoid breaking existing tests, update the mock to return 7-tuples in existing tests too, with empty strings for the last 3 fields.

  IMPORTANT: Check `tests/conftest.py` or `tests/mocks/db.py` to understand how `mock_db_pool` works. If it returns tuples directly, just extend the tuples. If it constructs rows differently, adapt accordingly.
  </action>
  <verify>
  Run `cd /Users/fzhdanov/GIT/personal/coco-s && python -m pytest tests/search/test_formatter.py tests/mcp/test_server.py -v` -- all existing and new tests pass.
  Run `cd /Users/fzhdanov/GIT/personal/coco-s && python -m pytest tests/ -v` -- full test suite passes (no regressions).
  </verify>
  <done>
  - TestFormatJsonMetadata verifies metadata fields in JSON output for DevOps and non-DevOps
  - TestFormatPrettyAnnotation verifies annotation prefix with language and hierarchy
  - TestExtensionLangMapDevOps verifies HCL extension mappings
  - TestSearchCode in MCP tests verifies metadata fields in response
  - All existing tests still pass (no regressions from SearchResult changes)
  - Full test suite green
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/search/test_formatter.py -v` -- all formatter tests pass
2. `python -m pytest tests/mcp/test_server.py -v` -- all MCP tests pass
3. `python -m pytest tests/ -v` -- full suite passes (no regressions)
4. Manual inspection: format_json output contains block_type, hierarchy, language_id keys
5. Manual inspection: format_pretty output contains [language] annotation line
6. Manual inspection: MCP response dict contains metadata fields
</verification>

<success_criteria>
- JSON output has block_type, hierarchy, language_id in every result (empty strings when unavailable)
- Pretty output shows [language] annotation prefix between score line and code block
- Pretty output shows hierarchy in annotation when non-empty (e.g., [hcl] resource.aws_s3_bucket.data)
- Non-DevOps files show extension-derived language tag (e.g., [python])
- HCL/Terraform files get HCL syntax highlighting in pretty output
- Dockerfile files get Docker syntax highlighting in pretty output
- MCP search_code response includes metadata fields with consistent shape
- MCP language parameter description updated for DevOps languages
- All tests pass including full regression suite
</success_criteria>

<output>
After completion, create `.planning/phases/04-search-and-output-integration/04-02-SUMMARY.md`
</output>
