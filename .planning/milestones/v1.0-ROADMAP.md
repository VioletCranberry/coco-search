# Milestone v1.0: CocoSearch MVP

**Status:** SHIPPED 2026-01-25
**Phases:** 1-4
**Total Plans:** 11

## Overview

CocoSearch delivers local-first semantic code search through a four-phase journey: establish infrastructure (PostgreSQL, Ollama), build the indexing pipeline (CocoIndex with Tree-sitter), implement vector search, and expose index management via MCP. Each phase delivers a coherent capability that depends on prior phases, culminating in a privacy-preserving code search tool that runs entirely on the developer's machine.

## Phases

### Phase 1: Foundation

**Goal**: Development environment with all infrastructure dependencies running and verified
**Depends on**: Nothing (first phase)
**Plans**: 2 plans

Plans:
- [x] 01-01-PLAN.md — Infrastructure setup: Docker Compose, Ollama model, Python project
- [x] 01-02-PLAN.md — Verification: pgvector extension, verification script, integration check

**Details:**
- PostgreSQL container with pgvector extension and persistent storage
- Ollama serving nomic-embed-text model with 768-dimensional embeddings
- Python project initialized with UV and all dependencies

### Phase 2: Indexing Pipeline

**Goal**: Users can index a codebase directory and have it stored as searchable embeddings
**Depends on**: Phase 1
**Plans**: 3 plans

Plans:
- [x] 02-01-PLAN.md — Config and file filtering: dependencies, IndexingConfig, .gitignore parsing
- [x] 02-02-PLAN.md — CocoIndex flow: Tree-sitter chunking, Ollama embeddings, PostgreSQL storage
- [x] 02-03-PLAN.md — CLI and progress: cocosearch index command, Rich progress display

**Details:**
- Code chunked by language structure (functions, classes) not arbitrary byte boundaries
- Files matching .gitignore patterns automatically excluded
- Include/exclude patterns for custom filtering
- Incremental indexing (only changed files processed)

### Phase 3: Search

**Goal**: Users can search indexed code with natural language and receive relevant results
**Depends on**: Phase 2
**Plans**: 3 plans

Plans:
- [x] 03-01-PLAN.md — Search core: database connection pool, query embedding, vector similarity search
- [x] 03-02-PLAN.md — CLI search command: JSON/pretty formatting, all flags, language filtering
- [x] 03-03-PLAN.md — Interactive REPL: --interactive mode with settings commands

**Details:**
- Natural language queries matched semantically
- Results include file path, line numbers, relevance scores
- Configurable result limits and language filtering
- Interactive REPL with readline support

### Phase 4: Index Management

**Goal**: Users can manage multiple named indexes and access all features through MCP tools
**Depends on**: Phase 3
**Plans**: 3 plans

Plans:
- [x] 04-01-PLAN.md — Management core: list_indexes, get_stats, clear_index, git root detection
- [x] 04-02-PLAN.md — CLI commands: list, stats, clear subcommands with JSON/pretty output
- [x] 04-03-PLAN.md — MCP server: FastMCP with search, list, stats, clear, index tools

**Details:**
- Multiple named indexes without conflicts
- Index statistics (file count, chunk count, size)
- MCP server with 5 tools for LLM integration

---

## Milestone Summary

**Key Decisions:**

- CocoIndex as indexing engine (user-specified, designed for this use case)
- Ollama for embeddings (local-first requirement)
- PostgreSQL in Docker (pgvector for vector storage)
- Reference-only storage (store filename + location, not chunk text)
- Direct PostgreSQL queries (simpler than CocoIndex query handlers)
- JSON output by default (MCP/tool integration)
- Git root detection for auto-index naming

**Issues Resolved:**

- None — clean implementation

**Technical Debt Incurred:**

- pathspec dependency in pyproject.toml is unused (patterns passed to CocoIndex directly)

---

*For current project status, see .planning/ROADMAP.md (if exists) or .planning/MILESTONES.md*
